# lsp.py - Language Server Protocol data structures and support functions
#
# Copyright 2024  by Eckhart Arnold (arnold@badw.de)
#                 Bavarian Academy of Sciences an Humanities (badw.de)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.  See the License for the specific language governing
# permissions and limitations under the License.

"""Module lsp.py defines (some of) the constants and data structures from
the Language Server Protocol. See:
<https://microsoft.github.io/language-server-protocol/specifications/specification-current/>

EXPERIMENTAL!!!
"""


import sys
from enum import Enum, IntEnum

from typing import Union, Optional, Any, Generic, TypeVar, Callable, List, \
    Iterable, Iterator, Tuple, Dict, Awaitable


try:
    from DHParser.ts2python.typeddict_shim import TypedDict, GenericTypedDict, NotRequired, Literal, \
        ReadOnly, TypeAlias
    # Override typing.TypedDict for Runtime-Validation
except ImportError:
    print("Module DHParser.ts2python.typeddict_shim not found. Only coarse-grained "
          "runtime type-validation of TypedDicts possible")
    try:
        from typing import TypedDict, Literal
    except ImportError:
        try:
            from DHParser.ts2python.typing_extensions import TypedDict, Literal
        except ImportError:
            print(f'Please install the "typing_extensions" module via the shell '
                  f'command "# pip install typing_extensions" before running '
                  f'{__file__} with Python-versions <= 3.8!')
    try:
        from typing_extensions import NotRequired, ReadOnly, TypeAlias
    except ImportError:
        NotRequired = Optional
        ReadOnly = Union
        TypeAlias = Any
    GenericMeta = type
    class _GenericTypedDictMeta(GenericMeta):
        def __new__(cls, name, bases, ns, total=True):
            return type.__new__(_GenericTypedDictMeta, name, (dict,), ns)
        __call__ = dict
    GenericTypedDict = _GenericTypedDictMeta('TypedDict', (dict,), {})
    GenericTypedDict.__module__ = __name__


#######################################################################
#
# Language-Server-Protocol data structures (AUTOGENERATED: Don't edit!)
#
#######################################################################


##### BEGIN OF ts2python generated code



# Defines an integer number in the range of -2^31 to 2^31 - 1.

integer = float


# Defines an unsigned integer number in the range of 0 to 2^31 - 1.

uinteger = float


# Defines a decimal number. Since decimal numbers are very
# rare in the language server specification we denote the
# exact range with every decimal using the mathematics
# interval notation (e.g. [0, 1] denotes all decimals d with
# 0 <= d <= 1.

decimal = float


# The LSP any type

# @since 3.17.0

LSPAny = Union['LSPObject', 'LSPArray', str, int, float, bool, None]


# LSP object definition.

# @since 3.17.0

LSPObject = Dict[str, LSPAny]


# LSP arrays.

# @since 3.17.0

LSPArray = List[LSPAny]


class Message(TypedDict):
    jsonrpc: str


class RequestMessage(Message, TypedDict):

    # The request id.
    id: Union[int, str]

    # The method to be invoked.
    method: str

    # The methodʼs params.
    params: NotRequired[Union[List, Dict]]


class ResponseMessage(Message, TypedDict):

    # The request id.
    id: Union[int, str, None]

    # The result of a request. This member is REQUIRED on success.
    # This member MUST NOT exist if there was an error invoking the method.
    result: NotRequired[LSPAny]

    # The error object in case a request fails.
    error: NotRequired['ResponseError']


class ResponseError(TypedDict):

    # A number indicating the error type that occurred.
    code: int

    # A string providing a short description of the error.
    message: str

    # A primitive or structured value that contains additional
    # information about the error. Can be omitted.
    data: NotRequired[LSPAny]

class ErrorCodes(IntEnum):

    # Defined by JSON-RPC
    ParseError = -32700
    InvalidRequest = -32600
    MethodNotFound = -32601
    InvalidParams = -32602
    InternalError = -32603

    # This is the start range of JSON-RPC reserved error codes.
    # It doesnʼt denote a real error code. No LSP error codes should
    # be defined between the start and end range. For backwards
    # compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
    # are left in the range.

    # @since 3.16.0
    jsonrpcReservedErrorRangeStart = -32099

    # @deprecated use jsonrpcReservedErrorRangeStart
    serverErrorStart = jsonrpcReservedErrorRangeStart

    # Error code indicating that a server received a notification or
    # request before the server received the `initialize` request.
    ServerNotInitialized = -32002
    UnknownErrorCode = -32001

    # This is the end range of JSON-RPC reserved error codes.
    # It doesnʼt denote a real error code.

    # @since 3.16.0
    jsonrpcReservedErrorRangeEnd = -32000

    # @deprecated use jsonrpcReservedErrorRangeEnd
    serverErrorEnd = jsonrpcReservedErrorRangeEnd

    # This is the start range of LSP reserved error codes.
    # It doesnʼt denote a real error code.

    # @since 3.16.0
    lspReservedErrorRangeStart = -32899

    # A request failed but it was syntactically correct, e.g the
    # method name was known and the parameters were valid. The error
    # message should contain human readable information about why
    # the request failed.

    # @since 3.17.0
    RequestFailed = -32803

    # The server cancelled the request. This error code should
    # only be used for requests that explicitly support being
    # server cancellable.

    # @since 3.17.0
    ServerCancelled = -32802

    # The server detected that the content of a document got
    # modified outside normal conditions. A server should
    # NOT send this error code if it detects a content change
    # in its unprocessed messages. The result even computed
    # on an older state might still be useful for the client.

    # If a client decides that a result is not of any use anymore
    # the client should cancel the request.
    ContentModified = -32801

    # The client has canceled a request and a server has detected
    # the cancel.
    RequestCancelled = -32800

    # This is the end range of LSP reserved error codes.
    # It doesnʼt denote a real error code.

    # @since 3.16.0
    lspReservedErrorRangeEnd = -32800


class NotificationMessage(Message, TypedDict):

    # The method to be invoked.
    method: str

    # The notificationʼs params.
    params: NotRequired[Union[List, Dict]]


class CancelParams(TypedDict):

    # The request id to cancel.
    id: Union[int, str]

ProgressToken = Union[int, str]

T = TypeVar('T')

class ProgressParams(Generic[T], GenericTypedDict):

    # The progress token provided by the client or server.
    token: ProgressToken

    # The progress data.
    value: T


class HoverParams(TypedDict):
    class Position_0(TypedDict):
        line: int
        character: int
    textDocument: str
    # The text documentʼs URI in string form
    position: Position_0


class HoverResult(TypedDict):
    value: str


# source file: "types/uri.md"

DocumentUri = str

URI = str


# source file: "types/regexp.md"

# Client capabilities specific to regular expressions.


class RegularExpressionsClientCapabilities(TypedDict):

    # The engineʼs name.
    engine: str

    # The engineʼs version.
    version: NotRequired[str]


# source file: "types/enumerations.md"


# source file: "types/textDocuments.md"

EOL: List[str] = ["\n", "\r\n", "\r"]


# source file: "types/position.md"


class Position(TypedDict):

    # Line position in a document (zero-based).
    line: int

    # Character offset on a line in a document (zero-based). The meaning of this
    # offset is determined by the negotiated `PositionEncodingKind`.

    # If the character value is greater than the line length it defaults back
    # to the line length.
    character: int


# A type indicating how positions are encoded,
# specifically what column offsets mean.

# @since 3.17.0

PositionEncodingKind = str


# A set of predefined position encoding kinds.

# @since 3.17.0

class PositionEncodingKind(Enum):

    # Character offsets count UTF-8 code units (e.g bytes).
    UTF8 = "utf-8"

    # Character offsets count UTF-16 code units.

    # This is the default and must always be supported
    # by servers
    UTF16 = "utf-16"

    # Character offsets count UTF-32 code units.

    # Implementation note: these are the same as Unicode code points,
    # so this `PositionEncodingKind` may also be used for an
    # encoding-agnostic representation of character offsets.
    UTF32 = "utf-32"


# source file: "types/range.md"


class Range(TypedDict):

    # The rangeʼs start position.
    start: Position

    # The rangeʼs end position.
    end: Position


# source file: "types/textDocumentItem.md"


class TextDocumentItem(TypedDict):

    # The text documentʼs URI.
    uri: DocumentUri

    # The text documentʼs language identifier.
    languageId: str

    # The version number of this document (it will increase after each
    # change, including undo/redo).
    version: int

    # The content of the opened text document.
    text: str


# source file: "types/textDocumentIdentifier.md"


class TextDocumentIdentifier(TypedDict):

    # The text documentʼs URI.
    uri: DocumentUri


# source file: "types/versionedTextDocumentIdentifier.md"


class VersionedTextDocumentIdentifier(TextDocumentIdentifier, TypedDict):

    # The version number of this document.

    # The version number of a document will increase after each change,
    # including undo/redo. The number doesnʼt need to be consecutive.
    version: int


class OptionalVersionedTextDocumentIdentifier(TextDocumentIdentifier, TypedDict):

    # The version number of this document. If an optional versioned text document
    # identifier is sent from the server to the client and the file is not
    # open in the editor (the server has not received an open notification
    # before) the server can send `null` to indicate that the version is
    # known and the content on disk is the master (as specified with document
    # content ownership).

    # The version number of a document will increase after each change,
    # including undo/redo. The number doesnʼt need to be consecutive.
    version: Union[int, None]


# source file: "types/textDocumentPositionParams.md"


class TextDocumentPositionParams(TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier

    # The position inside the text document.
    position: Position


# source file: "types/documentFilter.md"


class DocumentFilter(TypedDict):

    # A language id, like `typescript`.
    language: NotRequired[str]

    # A Uri scheme, like `file` or `untitled`.
    scheme: NotRequired[str]

    # A glob pattern, like `*.{ts,js}`.

    # Glob patterns can have the following syntax:
    # - `*` to match zero or more characters in a path segment
    # - `?` to match on one character in a path segment
    # - `**` to match any number of path segments, including none
    # - `{}` to group sub patterns into an OR expression. (e.g. `**​.{ts,js}`
    # matches all TypeScript and JavaScript files)
    # - `[]` to declare a range of characters to match in a path segment
    # (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
    # - `[!...]` to negate a range of characters to match in a path segment
    # (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but
    # not `example.0`)
    pattern: NotRequired[str]

DocumentSelector = List[DocumentFilter]


# source file: "types/textEdit.md"


class TextEdit(TypedDict):

    # The range of the text document to be manipulated. To insert
    # text into a document create a range where start === end.
    range: Range

    # The string to be inserted. For delete operations use an
    # empty string.
    newText: str


# Additional information that describes document changes.

# @since 3.16.0


class ChangeAnnotation(TypedDict):

    # A human-readable string describing the actual change. The string
    # is rendered prominent in the user interface.
    label: str

    # A flag which indicates that user confirmation is needed
    # before applying the change.
    needsConfirmation: NotRequired[bool]

    # A human-readable string which is rendered less prominent in
    # the user interface.
    description: NotRequired[str]


# An identifier referring to a change annotation managed by a workspace
# edit.

# @since 3.16.0.

ChangeAnnotationIdentifier = str


# A special text edit with an additional change annotation.

# @since 3.16.0.


class AnnotatedTextEdit(TextEdit, TypedDict):

    # The actual annotation identifier.
    annotationId: ChangeAnnotationIdentifier


# source file: "types/textEditArray.md"


# source file: "types/textDocumentEdit.md"


class TextDocumentEdit(TypedDict):

    # The text document to change.
    textDocument: OptionalVersionedTextDocumentIdentifier

    # The edits to be applied.

    # @since 3.16.0 - support for AnnotatedTextEdit. This is guarded by the
    # client capability `workspace.workspaceEdit.changeAnnotationSupport`
    edits: List[Union[TextEdit, AnnotatedTextEdit]]


# source file: "types/location.md"


class Location(TypedDict):
    uri: DocumentUri
    range: Range


# source file: "types/locationLink.md"


class LocationLink(TypedDict):

    # Span of the origin of this link.

    # Used as the underlined span for mouse interaction. Defaults to the word
    # range at the mouse position.
    originSelectionRange: NotRequired[Range]

    # The target resource identifier of this link.
    targetUri: DocumentUri

    # The full target range of this link. If the target for example is a symbol
    # then target range is the range enclosing this symbol not including
    # leading/trailing whitespace but everything else like comments. This
    # information is typically used to highlight the range in the editor.
    targetRange: Range

    # The range that should be selected and revealed when this link is being
    # followed, e.g the name of a function. Must be contained by the
    # `targetRange`. See also `DocumentSymbol#range`
    targetSelectionRange: Range


# source file: "types/diagnostic.md"


class Diagnostic(TypedDict):

    # The range at which the message applies.
    range: Range

    # The diagnosticʼs severity. To avoid interpretation mismatches when a
    # server is used with different clients it is highly recommended that
    # servers always provide a severity value. If omitted, it’s recommended
    # for the client to interpret it as an Error severity.
    severity: NotRequired['DiagnosticSeverity']

    # The diagnosticʼs code, which might appear in the user interface.
    code: NotRequired[Union[int, str]]

    # An optional property to describe the error code.

    # @since 3.16.0
    codeDescription: NotRequired['CodeDescription']

    # A human-readable string describing the source of this
    # diagnostic, e.g. ʼtypescriptʼ or ʼsuper lintʼ.
    source: NotRequired[str]

    # The diagnosticʼs message.
    message: str

    # Additional metadata about the diagnostic.

    # @since 3.15.0
    tags: NotRequired[List['DiagnosticTag']]

    # An array of related diagnostic information, e.g. when symbol-names within
    # a scope collide all definitions can be marked via this property.
    relatedInformation: NotRequired[List['DiagnosticRelatedInformation']]

    # A data entry field that is preserved between a
    # `textDocument/publishDiagnostics` notification and
    # `textDocument/codeAction` request.

    # @since 3.16.0
    data: NotRequired[LSPAny]

class DiagnosticSeverity(IntEnum):

    # Reports an error.
    Error = 1

    # Reports a warning.
    Warning = 2

    # Reports an information.
    Information = 3

    # Reports a hint.
    Hint = 4

# commented out, because there is already an enumeration with the same name
# DiagnosticSeverity = int


# The diagnostic tags.

# @since 3.15.0

class DiagnosticTag(IntEnum):

    # Unused or unnecessary code.

    # Clients are allowed to render diagnostics with this tag faded out
    # instead of having an error squiggle.
    Unnecessary = 1

    # Deprecated or obsolete code.

    # Clients are allowed to rendered diagnostics with this tag strike through.
    Deprecated = 2

# commented out, because there is already an enumeration with the same name
# DiagnosticTag = int


# Represents a related message and source code location for a diagnostic.
# This should be used to point to code locations that cause or are related to
# a diagnostics, e.g when duplicating a symbol in a scope.


class DiagnosticRelatedInformation(TypedDict):

    # The location of this related diagnostic information.
    location: Location

    # The message of this related diagnostic information.
    message: str


# Structure to capture a description for an error code.

# @since 3.16.0


class CodeDescription(TypedDict):

    # An URI to open with more information about the diagnostic error.
    href: URI


# source file: "types/command.md"


class Command(TypedDict):

    # Title of the command, like `save`.
    title: str

    # The identifier of the actual command handler.
    command: str

    # Arguments that the command handler should be
    # invoked with.
    arguments: NotRequired[List[LSPAny]]


# source file: "types/markupContent.md"

# Describes the content type that a client supports in various
# result literals like `Hover`, `ParameterInfo` or `CompletionItem`.

# Please note that `MarkupKinds` must not start with a `$`. This kinds
# are reserved for internal usage.

class MarkupKind(Enum):

    # Plain text is supported as a content format
    PlainText = "plaintext"

    # Markdown is supported as a content format
    Markdown = "markdown"

# commented out, because there is already an enumeration with the same name
# MarkupKind = str


# A `MarkupContent` literal represents a string value which content is
# interpreted base on its kind flag. Currently the protocol supports
# `plaintext` and `markdown` as markup kinds.

# If the kind is `markdown` then the value can contain fenced code blocks like
# in GitHub issues.

# Here is an example how such a string can be constructed using
# JavaScript / TypeScript:
# ```typescript
# let markdown: MarkdownContent = {
# kind: MarkupKind.Markdown,
# value: [
# ʼ# Headerʼ,
# ʼSome textʼ,
# ʼ```typescriptʼ,
# ʼsomeCode();ʼ,
# ʼ```ʼ
# ].join(ʼ\nʼ)
# };
# ```

# *Please Note* that clients might sanitize the return markdown. A client could
# decide to remove HTML from the markdown to avoid script execution.


class MarkupContent(TypedDict):

    # The type of the Markup
    kind: MarkupKind

    # The content itself
    value: str


# Client capabilities specific to the used markdown parser.

# @since 3.16.0


class MarkdownClientCapabilities(TypedDict):

    # The name of the parser.
    parser: str

    # The version of the parser.
    version: NotRequired[str]

    # A list of HTML tags that the client allows / supports in
    # Markdown.

    # @since 3.17.0
    allowedTags: NotRequired[List[str]]


# source file: "types/resourceChanges.md"

# Options to create a file.


class CreateFileOptions(TypedDict):

    # Overwrite existing file. Overwrite wins over `ignoreIfExists`
    overwrite: NotRequired[bool]

    # Ignore if exists.
    ignoreIfExists: NotRequired[bool]


# Create file operation


class CreateFile(TypedDict):

    # A create
    kind: str

    # The resource to create.
    uri: DocumentUri

    # Additional options
    options: NotRequired[CreateFileOptions]

    # An optional annotation identifier describing the operation.

    # @since 3.16.0
    annotationId: NotRequired[ChangeAnnotationIdentifier]


# Rename file options


class RenameFileOptions(TypedDict):

    # Overwrite target if existing. Overwrite wins over `ignoreIfExists`
    overwrite: NotRequired[bool]

    # Ignores if target exists.
    ignoreIfExists: NotRequired[bool]


# Rename file operation


class RenameFile(TypedDict):

    # A rename
    kind: str

    # The old (existing) location.
    oldUri: DocumentUri

    # The new location.
    newUri: DocumentUri

    # Rename options.
    options: NotRequired[RenameFileOptions]

    # An optional annotation identifier describing the operation.

    # @since 3.16.0
    annotationId: NotRequired[ChangeAnnotationIdentifier]


# Delete file options


class DeleteFileOptions(TypedDict):

    # Delete the content recursively if a folder is denoted.
    recursive: NotRequired[bool]

    # Ignore the operation if the file doesnʼt exist.
    ignoreIfNotExists: NotRequired[bool]


# Delete file operation


class DeleteFile(TypedDict):

    # A delete
    kind: str

    # The file to delete.
    uri: DocumentUri

    # Delete options.
    options: NotRequired[DeleteFileOptions]

    # An optional annotation identifier describing the operation.

    # @since 3.16.0
    annotationId: NotRequired[ChangeAnnotationIdentifier]


# source file: "types/workspaceEdit.md"


class WorkspaceEdit(TypedDict):

    # Holds changes to existing resources.
    changes: NotRequired[Dict[DocumentUri, List[TextEdit]]]

    # Depending on the client capability
    # `workspace.workspaceEdit.resourceOperations` document changes are either
    # an array of `TextDocumentEdit`s to express changes to n different text
    # documents where each text document edit addresses a specific version of
    # a text document. Or it can contain above `TextDocumentEdit`s mixed with
    # create, rename and delete file / folder operations.

    # Whether a client supports versioned document edits is expressed via
    # `workspace.workspaceEdit.documentChanges` client capability.

    # If a client neither supports `documentChanges` nor
    # `workspace.workspaceEdit.resourceOperations` then only plain `TextEdit`s
    # using the `changes` property are supported.
    documentChanges: NotRequired[Union[List[TextDocumentEdit], List[Union[TextDocumentEdit, CreateFile, RenameFile, DeleteFile]]]]

    # A map of change annotations that can be referenced in
    # `AnnotatedTextEdit`s or create, rename and delete file / folder
    # operations.

    # Whether clients honor this property depends on the client capability
    # `workspace.changeAnnotationSupport`.

    # @since 3.16.0
    changeAnnotations: NotRequired[Dict[str, ChangeAnnotation]]


class WorkspaceEditClientCapabilities(TypedDict):
    class ChangeAnnotationSupport_0(TypedDict):

        # Whether the client groups edits with equal labels into tree nodes,
        # for instance all edits labelled with "Changes in Strings" would
        # be a tree node.
        groupsOnLabel: NotRequired[bool]

    # The client supports versioned document changes in `WorkspaceEdit`s
    documentChanges: NotRequired[bool]

    # The resource operations the client supports. Clients should at least
    # support ʼcreateʼ, ʼrenameʼ and ʼdeleteʼ files and folders.

    # @since 3.13.0
    resourceOperations: NotRequired[List['ResourceOperationKind']]

    # The failure handling strategy of a client if applying the workspace edit
    # fails.

    # @since 3.13.0
    failureHandling: NotRequired['FailureHandlingKind']

    # Whether the client normalizes line endings to the client specific
    # setting.
    # If set to `true` the client will normalize line ending characters
    # in a workspace edit to the client specific new line character(s).

    # @since 3.16.0
    normalizesLineEndings: NotRequired[bool]

    # Whether the client in general supports change annotations on text edits,
    # create file, rename file and delete file changes.

    # @since 3.16.0
    changeAnnotationSupport: NotRequired[ChangeAnnotationSupport_0]


# The kind of resource operations supported by the client.

ResourceOperationKind = str

class ResourceOperationKind(Enum):

    # Supports creating new files and folders.
    Create = "create"

    # Supports renaming existing files and folders.
    Rename = "rename"

    # Supports deleting existing files and folders.
    Delete = "delete"

FailureHandlingKind = str

class FailureHandlingKind(Enum):

    # Applying the workspace change is simply aborted if one of the changes
    # provided fails. All operations executed before the failing operation
    # stay executed.
    Abort = "abort"

    # All operations are executed transactional. That means they either all
    # succeed or no changes at all are applied to the workspace.
    Transactional = "transactional"

    # If the workspace edit contains only textual file changes they are
    # executed transactional. If resource changes (create, rename or delete
    # file) are part of the change the failure handling strategy is abort.
    TextOnlyTransactional = "textOnlyTransactional"

    # The client tries to undo the operations already executed. But there is no
    # guarantee that this is succeeding.
    Undo = "undo"


# source file: "types/workDoneProgress.md"


class WorkDoneProgressBegin(TypedDict):
    kind: str

    # Mandatory title of the progress operation. Used to briefly inform about
    # the kind of operation being performed.

    # Examples: "Indexing" or "Linking dependencies".
    title: str

    # Controls if a cancel button should show to allow the user to cancel the
    # long running operation. Clients that donʼt support cancellation are
    # allowed to ignore the setting.
    cancellable: NotRequired[bool]

    # Optional, more detailed associated progress message. Contains
    # complementary information to the `title`.

    # Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
    # If unset, the previous progress message (if any) is still valid.
    message: NotRequired[str]

    # Optional progress percentage to display (value 100 is considered 100%).
    # If not provided infinite progress is assumed and clients are allowed
    # to ignore the `percentage` value in subsequent report notifications.

    # The value should be steadily rising. Clients are free to ignore values
    # that are not following this rule. The value range is [0, 100].
    percentage: NotRequired[int]


class WorkDoneProgressReport(TypedDict):
    kind: str

    # Controls enablement state of a cancel button. This property is only valid
    # if a cancel button got requested in the `WorkDoneProgressBegin` payload.

    # Clients that donʼt support cancellation or donʼt support control the
    # buttonʼs enablement state are allowed to ignore the setting.
    cancellable: NotRequired[bool]

    # Optional, more detailed associated progress message. Contains
    # complementary information to the `title`.

    # Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
    # If unset, the previous progress message (if any) is still valid.
    message: NotRequired[str]

    # Optional progress percentage to display (value 100 is considered 100%).
    # If not provided infinite progress is assumed and clients are allowed
    # to ignore the `percentage` value in subsequent report notifications.

    # The value should be steadily rising. Clients are free to ignore values
    # that are not following this rule. The value range is [0, 100].
    percentage: NotRequired[int]


class WorkDoneProgressEnd(TypedDict):
    kind: str

    # Optional, a final message indicating to for example indicate the outcome
    # of the operation.
    message: NotRequired[str]


class WorkDoneProgressParams(TypedDict):

    # An optional token that a server can use to report work done progress.
    workDoneToken: NotRequired[ProgressToken]


class WorkDoneProgressOptions(TypedDict):
    workDoneProgress: NotRequired[bool]


# Window specific client capabilities.


# source file: "types/partialResults.md"


# source file: "types/partialResultParams.md"


class PartialResultParams(TypedDict):

    # An optional token that a server can use to report partial results (e.g.
    # streaming) to the client.
    partialResultToken: NotRequired[ProgressToken]


# source file: "types/traceValue.md"

TraceValue = str


# source file: "general/initialize.md"


class InitializeParams(WorkDoneProgressParams, TypedDict):
    class ClientInfo_0(TypedDict):

        # The name of the client as defined by the client.
        name: str

        # The clientʼs version as defined by the client.
        version: NotRequired[str]

    # The process Id of the parent process that started the server. Is null if
    # the process has not been started by another process. If the parent
    # process is not alive then the server should exit (see exit notification)
    # its process.
    processId: Union[int, None]

    # Information about the client

    # @since 3.15.0
    clientInfo: NotRequired[ClientInfo_0]

    # The locale the client is currently showing the user interface
    # in. This must not necessarily be the locale of the operating
    # system.

    # Uses IETF language tags as the valueʼs syntax
    # (See https:en.wikipedia.org/wiki/IETF_language_tag)

    # @since 3.16.0
    locale: NotRequired[str]

    # The rootPath of the workspace. Is null
    # if no folder is open.

    # @deprecated in favour of `rootUri`.
    rootPath: NotRequired[Union[str, None]]

    # The rootUri of the workspace. Is null if no
    # folder is open. If both `rootPath` and `rootUri` are set
    # `rootUri` wins.

    # @deprecated in favour of `workspaceFolders`
    rootUri: Union[DocumentUri, None]

    # User provided initialization options.
    initializationOptions: NotRequired[LSPAny]

    # The capabilities provided by the client (editor or tool)
    capabilities: 'ClientCapabilities'

    # The initial trace setting. If omitted trace is disabled (ʼoffʼ).
    trace: NotRequired[TraceValue]

    # The workspace folders configured in the client when the server starts.
    # This property is only available if the client supports workspace folders.
    # It can be `null` if the client supports workspace folders but none are
    # configured.

    # @since 3.6.0
    workspaceFolders: NotRequired[Union[List['WorkspaceFolder'], None]]


# Text document specific client capabilities.


class TextDocumentClientCapabilities(TypedDict):
    synchronization: NotRequired['TextDocumentSyncClientCapabilities']

    # Capabilities specific to the `textDocument/completion` request.
    completion: NotRequired['CompletionClientCapabilities']

    # Capabilities specific to the `textDocument/hover` request.
    hover: NotRequired['HoverClientCapabilities']

    # Capabilities specific to the `textDocument/signatureHelp` request.
    signatureHelp: NotRequired['SignatureHelpClientCapabilities']

    # Capabilities specific to the `textDocument/declaration` request.

    # @since 3.14.0
    declaration: NotRequired['DeclarationClientCapabilities']

    # Capabilities specific to the `textDocument/definition` request.
    definition: NotRequired['DefinitionClientCapabilities']

    # Capabilities specific to the `textDocument/typeDefinition` request.

    # @since 3.6.0
    typeDefinition: NotRequired['TypeDefinitionClientCapabilities']

    # Capabilities specific to the `textDocument/implementation` request.

    # @since 3.6.0
    implementation: NotRequired['ImplementationClientCapabilities']

    # Capabilities specific to the `textDocument/references` request.
    references: NotRequired['ReferenceClientCapabilities']

    # Capabilities specific to the `textDocument/documentHighlight` request.
    documentHighlight: NotRequired['DocumentHighlightClientCapabilities']

    # Capabilities specific to the `textDocument/documentSymbol` request.
    documentSymbol: NotRequired['DocumentSymbolClientCapabilities']

    # Capabilities specific to the `textDocument/codeAction` request.
    codeAction: NotRequired['CodeActionClientCapabilities']

    # Capabilities specific to the `textDocument/codeLens` request.
    codeLens: NotRequired['CodeLensClientCapabilities']

    # Capabilities specific to the `textDocument/documentLink` request.
    documentLink: NotRequired['DocumentLinkClientCapabilities']

    # Capabilities specific to the `textDocument/documentColor` and the
    # `textDocument/colorPresentation` request.

    # @since 3.6.0
    colorProvider: NotRequired['DocumentColorClientCapabilities']

    # Capabilities specific to the `textDocument/formatting` request.
    formatting: NotRequired['DocumentFormattingClientCapabilities']

    # Capabilities specific to the `textDocument/rangeFormatting` request.
    rangeFormatting: NotRequired['DocumentRangeFormattingClientCapabilities']

    # request.
    # Capabilities specific to the `textDocument/onTypeFormatting` request.
    onTypeFormatting: NotRequired['DocumentOnTypeFormattingClientCapabilities']

    # Capabilities specific to the `textDocument/rename` request.
    rename: NotRequired['RenameClientCapabilities']

    # Capabilities specific to the `textDocument/publishDiagnostics`
    # notification.
    publishDiagnostics: NotRequired['PublishDiagnosticsClientCapabilities']

    # Capabilities specific to the `textDocument/foldingRange` request.

    # @since 3.10.0
    foldingRange: NotRequired['FoldingRangeClientCapabilities']

    # Capabilities specific to the `textDocument/selectionRange` request.

    # @since 3.15.0
    selectionRange: NotRequired['SelectionRangeClientCapabilities']

    # Capabilities specific to the `textDocument/linkedEditingRange` request.

    # @since 3.16.0
    linkedEditingRange: NotRequired['LinkedEditingRangeClientCapabilities']

    # Capabilities specific to the various call hierarchy requests.

    # @since 3.16.0
    callHierarchy: NotRequired['CallHierarchyClientCapabilities']

    # Capabilities specific to the various semantic token requests.

    # @since 3.16.0
    semanticTokens: NotRequired['SemanticTokensClientCapabilities']

    # Capabilities specific to the `textDocument/moniker` request.

    # @since 3.16.0
    moniker: NotRequired['MonikerClientCapabilities']

    # Capabilities specific to the various type hierarchy requests.

    # @since 3.17.0
    typeHierarchy: NotRequired['TypeHierarchyClientCapabilities']

    # Capabilities specific to the `textDocument/inlineValue` request.

    # @since 3.17.0
    inlineValue: NotRequired['InlineValueClientCapabilities']

    # Capabilities specific to the `textDocument/inlayHint` request.

    # @since 3.17.0
    inlayHint: NotRequired['InlayHintClientCapabilities']

    # Capabilities specific to the diagnostic pull model.

    # @since 3.17.0
    diagnostic: NotRequired['DiagnosticClientCapabilities']


# Capabilities specific to the notebook document support.

# @since 3.17.0


class NotebookDocumentClientCapabilities(TypedDict):

    # Capabilities specific to notebook document synchronization

    # @since 3.17.0
    synchronization: 'NotebookDocumentSyncClientCapabilities'


class ClientCapabilities(TypedDict):
    class Workspace_0(TypedDict):
        class FileOperations_0(TypedDict):

            # Whether the client supports dynamic registration for file
            # requests/notifications.
            dynamicRegistration: NotRequired[bool]

            # The client has support for sending didCreateFiles notifications.
            didCreate: NotRequired[bool]

            # The client has support for sending willCreateFiles requests.
            willCreate: NotRequired[bool]

            # The client has support for sending didRenameFiles notifications.
            didRename: NotRequired[bool]

            # The client has support for sending willRenameFiles requests.
            willRename: NotRequired[bool]

            # The client has support for sending didDeleteFiles notifications.
            didDelete: NotRequired[bool]

            # The client has support for sending willDeleteFiles requests.
            willDelete: NotRequired[bool]

        # The client supports applying batch edits
        # to the workspace by supporting the request
        # ʼworkspace/applyEditʼ
        applyEdit: NotRequired[bool]

        # Capabilities specific to `WorkspaceEdit`s
        workspaceEdit: NotRequired[WorkspaceEditClientCapabilities]

        # Capabilities specific to the `workspace/didChangeConfiguration`
        # notification.
        didChangeConfiguration: NotRequired['DidChangeConfigurationClientCapabilities']

        # Capabilities specific to the `workspace/didChangeWatchedFiles`
        # notification.
        didChangeWatchedFiles: NotRequired['DidChangeWatchedFilesClientCapabilities']

        # Capabilities specific to the `workspace/symbol` request.
        symbol: NotRequired['WorkspaceSymbolClientCapabilities']

        # Capabilities specific to the `workspace/executeCommand` request.
        executeCommand: NotRequired['ExecuteCommandClientCapabilities']

        # The client has support for workspace folders.

        # @since 3.6.0
        workspaceFolders: NotRequired[bool]

        # The client supports `workspace/configuration` requests.

        # @since 3.6.0
        configuration: NotRequired[bool]

        # Capabilities specific to the semantic token requests scoped to the
        # workspace.

        # @since 3.16.0
        semanticTokens: NotRequired['SemanticTokensWorkspaceClientCapabilities']

        # Capabilities specific to the code lens requests scoped to the
        # workspace.

        # @since 3.16.0
        codeLens: NotRequired['CodeLensWorkspaceClientCapabilities']

        # The client has support for file requests/notifications.

        # @since 3.16.0
        fileOperations: NotRequired[FileOperations_0]

        # Client workspace capabilities specific to inline values.

        # @since 3.17.0
        inlineValue: NotRequired['InlineValueWorkspaceClientCapabilities']

        # Client workspace capabilities specific to inlay hints.

        # @since 3.17.0
        inlayHint: NotRequired['InlayHintWorkspaceClientCapabilities']

        # Client workspace capabilities specific to diagnostics.

        # @since 3.17.0.
        diagnostics: NotRequired['DiagnosticWorkspaceClientCapabilities']
    class Window_0(TypedDict):

        # It indicates whether the client supports server initiated
        # progress using the `window/workDoneProgress/create` request.

        # The capability also controls Whether client supports handling
        # of progress notifications. If set servers are allowed to report a
        # `workDoneProgress` property in the request specific server
        # capabilities.

        # @since 3.15.0
        workDoneProgress: NotRequired[bool]

        # Capabilities specific to the showMessage request

        # @since 3.16.0
        showMessage: NotRequired['ShowMessageRequestClientCapabilities']

        # Client capabilities for the show document request.

        # @since 3.16.0
        showDocument: NotRequired['ShowDocumentClientCapabilities']
    class General_0(TypedDict):
        class StaleRequestSupport_0(TypedDict):

            # The client will actively cancel the request.
            cancel: bool

            # The list of requests for which the client
            # will retry the request if it receives a
            # response with error code `ContentModified``
            retryOnContentModified: List[str]

        # Client capability that signals how the client
        # handles stale requests (e.g. a request
        # for which the client will not process the response
        # anymore since the information is outdated).

        # @since 3.17.0
        staleRequestSupport: NotRequired[StaleRequestSupport_0]

        # Client capabilities specific to regular expressions.

        # @since 3.16.0
        regularExpressions: NotRequired[RegularExpressionsClientCapabilities]

        # Client capabilities specific to the clientʼs markdown parser.

        # @since 3.16.0
        markdown: NotRequired[MarkdownClientCapabilities]

        # The position encodings supported by the client. Client and server
        # have to agree on the same position encoding to ensure that offsets
        # (e.g. character position in a line) are interpreted the same on both
        # side.

        # To keep the protocol backwards compatible the following applies: if
        # the value ʼutf-16ʼ is missing from the array of position encodings
        # servers can assume that the client supports UTF-16. UTF-16 is
        # therefore a mandatory encoding.

        # If omitted it defaults to [ʼutf-16ʼ].

        # Implementation considerations: since the conversion from one encoding
        # into another requires the content of the file / line the conversion
        # is best done where the file is read which is usually on the server
        # side.

        # @since 3.17.0
        positionEncodings: NotRequired[List[PositionEncodingKind]]

    # Workspace specific client capabilities.
    workspace: NotRequired[Workspace_0]

    # Text document specific client capabilities.
    textDocument: NotRequired[TextDocumentClientCapabilities]

    # Capabilities specific to the notebook document support.

    # @since 3.17.0
    notebookDocument: NotRequired[NotebookDocumentClientCapabilities]

    # Window specific client capabilities.
    window: NotRequired[Window_0]

    # General client capabilities.

    # @since 3.16.0
    general: NotRequired[General_0]

    # Experimental client capabilities.
    experimental: NotRequired[LSPAny]


class InitializeResult(TypedDict):
    class ServerInfo_0(TypedDict):

        # The name of the server as defined by the server.
        name: str

        # The serverʼs version as defined by the server.
        version: NotRequired[str]

    # The capabilities the language server provides.
    capabilities: 'ServerCapabilities'

    # Information about the server.

    # @since 3.15.0
    serverInfo: NotRequired[ServerInfo_0]


# Known error codes for an `InitializeErrorCodes`;

class InitializeErrorCodes(IntEnum):

    # If the protocol version provided by the client canʼt be handled by
    # the server.

    # @deprecated This initialize error got replaced by client capabilities.
    # There is no version handshake in version 3.0x
    unknownProtocolVersion = 1

# commented out, because there is already an enumeration with the same name
# InitializeErrorCodes = int


class InitializeError(TypedDict):

    # Indicates whether the client execute the following retry logic:
    # (1) show the message provided by the ResponseError to the user
    # (2) user selects retry or cancel
    # (3) if user selected retry the initialize method is sent again.
    retry: bool


class ServerCapabilities(TypedDict):
    class Workspace_0(TypedDict):
        class FileOperations_0(TypedDict):

            # The server is interested in receiving didCreateFiles
            # notifications.
            didCreate: NotRequired['FileOperationRegistrationOptions']

            # The server is interested in receiving willCreateFiles requests.
            willCreate: NotRequired['FileOperationRegistrationOptions']

            # The server is interested in receiving didRenameFiles
            # notifications.
            didRename: NotRequired['FileOperationRegistrationOptions']

            # The server is interested in receiving willRenameFiles requests.
            willRename: NotRequired['FileOperationRegistrationOptions']

            # The server is interested in receiving didDeleteFiles file
            # notifications.
            didDelete: NotRequired['FileOperationRegistrationOptions']

            # The server is interested in receiving willDeleteFiles file
            # requests.
            willDelete: NotRequired['FileOperationRegistrationOptions']

        # The server supports workspace folder.

        # @since 3.6.0
        workspaceFolders: NotRequired['WorkspaceFoldersServerCapabilities']

        # The server is interested in file notifications/requests.

        # @since 3.16.0
        fileOperations: NotRequired[FileOperations_0]

    # The position encoding the server picked from the encodings offered
    # by the client via the client capability `general.positionEncodings`.

    # If the client didnʼt provide any position encodings the only valid
    # value that a server can return is ʼutf-16ʼ.

    # If omitted it defaults to ʼutf-16ʼ.

    # @since 3.17.0
    positionEncoding: NotRequired[PositionEncodingKind]

    # Defines how text documents are synced. Is either a detailed structure
    # defining each notification or for backwards compatibility the
    # TextDocumentSyncKind number. If omitted it defaults to
    # `TextDocumentSyncKind.None`.
    textDocumentSync: NotRequired[Union['TextDocumentSyncOptions', 'TextDocumentSyncKind']]

    # Defines how notebook documents are synced.

    # @since 3.17.0
    notebookDocumentSync: NotRequired[Union['NotebookDocumentSyncOptions', 'NotebookDocumentSyncRegistrationOptions']]

    # The server provides completion support.
    completionProvider: NotRequired['CompletionOptions']

    # The server provides hover support.
    hoverProvider: NotRequired[Union[bool, 'HoverOptions']]

    # The server provides signature help support.
    signatureHelpProvider: NotRequired['SignatureHelpOptions']

    # The server provides go to declaration support.

    # @since 3.14.0
    declarationProvider: NotRequired[Union[bool, 'DeclarationOptions', 'DeclarationRegistrationOptions']]

    # The server provides goto definition support.
    definitionProvider: NotRequired[Union[bool, 'DefinitionOptions']]

    # The server provides goto type definition support.

    # @since 3.6.0
    typeDefinitionProvider: NotRequired[Union[bool, 'TypeDefinitionOptions', 'TypeDefinitionRegistrationOptions']]

    # The server provides goto implementation support.

    # @since 3.6.0
    implementationProvider: NotRequired[Union[bool, 'ImplementationOptions', 'ImplementationRegistrationOptions']]

    # The server provides find references support.
    referencesProvider: NotRequired[Union[bool, 'ReferenceOptions']]

    # The server provides document highlight support.
    documentHighlightProvider: NotRequired[Union[bool, 'DocumentHighlightOptions']]

    # The server provides document symbol support.
    documentSymbolProvider: NotRequired[Union[bool, 'DocumentSymbolOptions']]

    # The server provides code actions. The `CodeActionOptions` return type is
    # only valid if the client signals code action literal support via the
    # property `textDocument.codeAction.codeActionLiteralSupport`.
    codeActionProvider: NotRequired[Union[bool, 'CodeActionOptions']]

    # The server provides code lens.
    codeLensProvider: NotRequired['CodeLensOptions']

    # The server provides document link support.
    documentLinkProvider: NotRequired['DocumentLinkOptions']

    # The server provides color provider support.

    # @since 3.6.0
    colorProvider: NotRequired[Union[bool, 'DocumentColorOptions', 'DocumentColorRegistrationOptions']]

    # The server provides document formatting.
    documentFormattingProvider: NotRequired[Union[bool, 'DocumentFormattingOptions']]

    # The server provides document range formatting.
    documentRangeFormattingProvider: NotRequired[Union[bool, 'DocumentRangeFormattingOptions']]

    # The server provides document formatting on typing.
    documentOnTypeFormattingProvider: NotRequired['DocumentOnTypeFormattingOptions']

    # The server provides rename support. RenameOptions may only be
    # specified if the client states that it supports
    # `prepareSupport` in its initial `initialize` request.
    renameProvider: NotRequired[Union[bool, 'RenameOptions']]

    # The server provides folding provider support.

    # @since 3.10.0
    foldingRangeProvider: NotRequired[Union[bool, 'FoldingRangeOptions', 'FoldingRangeRegistrationOptions']]

    # The server provides execute command support.
    executeCommandProvider: NotRequired['ExecuteCommandOptions']

    # The server provides selection range support.

    # @since 3.15.0
    selectionRangeProvider: NotRequired[Union[bool, 'SelectionRangeOptions', 'SelectionRangeRegistrationOptions']]

    # The server provides linked editing range support.

    # @since 3.16.0
    linkedEditingRangeProvider: NotRequired[Union[bool, 'LinkedEditingRangeOptions', 'LinkedEditingRangeRegistrationOptions']]

    # The server provides call hierarchy support.

    # @since 3.16.0
    callHierarchyProvider: NotRequired[Union[bool, 'CallHierarchyOptions', 'CallHierarchyRegistrationOptions']]

    # The server provides semantic tokens support.

    # @since 3.16.0
    semanticTokensProvider: NotRequired[Union['SemanticTokensOptions', 'SemanticTokensRegistrationOptions']]

    # Whether server provides moniker support.

    # @since 3.16.0
    monikerProvider: NotRequired[Union[bool, 'MonikerOptions', 'MonikerRegistrationOptions']]

    # The server provides type hierarchy support.

    # @since 3.17.0
    typeHierarchyProvider: NotRequired[Union[bool, 'TypeHierarchyOptions', 'TypeHierarchyRegistrationOptions']]

    # The server provides inline values.

    # @since 3.17.0
    inlineValueProvider: NotRequired[Union[bool, 'InlineValueOptions', 'InlineValueRegistrationOptions']]

    # The server provides inlay hints.

    # @since 3.17.0
    inlayHintProvider: NotRequired[Union[bool, 'InlayHintOptions', 'InlayHintRegistrationOptions']]

    # The server has support for pull model diagnostics.

    # @since 3.17.0
    diagnosticProvider: NotRequired[Union['DiagnosticOptions', 'DiagnosticRegistrationOptions']]

    # The server provides workspace symbol support.
    workspaceSymbolProvider: NotRequired[Union[bool, 'WorkspaceSymbolOptions']]

    # Workspace specific server capabilities
    workspace: NotRequired[Workspace_0]

    # Experimental server capabilities.
    experimental: NotRequired[LSPAny]


# source file: "messages/3.17/initialized.md"


class InitializedParams(TypedDict):
    pass


class Registration(TypedDict):

    # The id used to register the request. The id can be used to deregister
    # the request again.
    id: str

    # The method / capability to register for.
    method: str

    # Options necessary for the registration.
    registerOptions: NotRequired[LSPAny]


class RegistrationParams(TypedDict):
    registrations: List[Registration]


# Static registration options to be returned in the initialize request.


class StaticRegistrationOptions(TypedDict):

    # The id used to register the request. The id can be used to deregister
    # the request again. See also Registration#id.
    id: NotRequired[str]


# General text document registration options.


class TextDocumentRegistrationOptions(TypedDict):

    # A document selector to identify the scope of the registration. If set to
    # null the document selector provided on the client side will be used.
    documentSelector: Union[DocumentSelector, None]


# source file: "messages/3.17/unregisterCapability.md"

# General parameters to unregister a capability.


class Unregistration(TypedDict):

    # The id used to unregister the request or notification. Usually an id
    # provided during the register request.
    id: str

    # The method / capability to unregister for.
    method: str


class UnregistrationParams(TypedDict):

    # This should correctly be named `unregistrations`. However changing this
    # is a breaking change and needs to wait until we deliver a 4.x version
    # of the specification.
    unregisterations: List[Unregistration]


# source file: "messages/3.17/setTrace.md"


class SetTraceParams(TypedDict):

    # The new value that should be assigned to the trace setting.
    value: TraceValue


# source file: "messages/3.17/logTrace.md"


class LogTraceParams(TypedDict):

    # The message to be logged.
    message: str

    # Additional information that can be computed if the `trace` configuration
    # is set to `ʼverboseʼ`
    verbose: NotRequired[str]


# source file: "messages/3.17/shutdown.md"


# source file: "messages/3.17/exit.md"

# Defines how the host (editor) should sync document changes to the language
# server.

class TextDocumentSyncKind(IntEnum):

    # Documents should not be synced at all.
    None_ = 0

    # Documents are synced by always sending the full content
    # of the document.
    Full = 1

    # Documents are synced by sending the full content on open.
    # After that only incremental updates to the document are
    # sent.
    Incremental = 2

# commented out, because there is already an enumeration with the same name
# TextDocumentSyncKind = int


class TextDocumentSyncOptions(TypedDict):

    # Open and close notifications are sent to the server. If omitted open
    # close notifications should not be sent.
    openClose: NotRequired[bool]

    # Change notifications are sent to the server. See
    # TextDocumentSyncKind.None, TextDocumentSyncKind.Full and
    # TextDocumentSyncKind.Incremental. If omitted it defaults to
    # TextDocumentSyncKind.None.
    change: NotRequired[TextDocumentSyncKind]


# source file: "textDocument/didOpen.md"


class DidOpenTextDocumentParams(TypedDict):

    # The document that was opened.
    textDocument: TextDocumentItem


# source file: "textDocument/didChange.md"

# Describe options to be used when registering for text document change events.


class TextDocumentChangeRegistrationOptions(TextDocumentRegistrationOptions, TypedDict):

    # How documents are synced to the server. See TextDocumentSyncKind.Full
    # and TextDocumentSyncKind.Incremental.
    syncKind: TextDocumentSyncKind


class DidChangeTextDocumentParams(TypedDict):

    # The document that did change. The version number points
    # to the version after all provided content changes have
    # been applied.
    textDocument: VersionedTextDocumentIdentifier

    # The actual content changes. The content changes describe single state
    # changes to the document. So if there are two content changes c1 (at
    # array index 0) and c2 (at array index 1) for a document in state S then
    # c1 moves the document from S to Sʼ and c2 from Sʼ to Sʼʼ. So c1 is
    # computed on the state S and c2 is computed on the state Sʼ.

    # To mirror the content of a document using change events use the following
    # approach:
    # - start with the same initial content
    # - apply the ʼtextDocument/didChangeʼ notifications in the order you
    # receive them.
    # - apply the `TextDocumentContentChangeEvent`s in a single notification
    # in the order you receive them.
    contentChanges: List['TextDocumentContentChangeEvent']


# An event describing a change to a text document. If only a text is provided
# it is considered to be the full content of the document.

class TextDocumentContentChangeEvent_0(TypedDict):

    # The range of the document that changed.
    range: Range

    # The optional length of the range that got replaced.

    # @deprecated use range instead.
    rangeLength: NotRequired[int]

    # The new text for the provided range.
    text: str
class TextDocumentContentChangeEvent_1(TypedDict):

    # The new text of the whole document.
    text: str
TextDocumentContentChangeEvent = Union[TextDocumentContentChangeEvent_0, TextDocumentContentChangeEvent_1]


# source file: "textDocument/willSave.md"

# The parameters send in a will save text document notification.


class WillSaveTextDocumentParams(TypedDict):

    # The document that will be saved.
    textDocument: TextDocumentIdentifier

    # The ʼTextDocumentSaveReasonʼ.
    reason: 'TextDocumentSaveReason'


# Represents reasons why a text document is saved.

class TextDocumentSaveReason(IntEnum):

    # Manually triggered, e.g. by the user pressing save, by starting
    # debugging, or by an API call.
    Manual = 1

    # Automatic after a delay.
    AfterDelay = 2

    # When the editor lost focus.
    FocusOut = 3

# commented out, because there is already an enumeration with the same name
# TextDocumentSaveReason = int


# source file: "textDocument/willSaveWaitUntil.md"


# source file: "textDocument/didSave.md"


class SaveOptions(TypedDict):

    # The client is supposed to include the content on save.
    includeText: NotRequired[bool]


class TextDocumentSaveRegistrationOptions(TextDocumentRegistrationOptions, TypedDict):

    # The client is supposed to include the content on save.
    includeText: NotRequired[bool]


class DidSaveTextDocumentParams(TypedDict):

    # The document that was saved.
    textDocument: TextDocumentIdentifier

    # Optional the content when saved. Depends on the includeText value
    # when the save notification was requested.
    text: NotRequired[str]


# source file: "textDocument/didClose.md"


class DidCloseTextDocumentParams(TypedDict):

    # The document that was closed.
    textDocument: TextDocumentIdentifier


# source file: "textDocument/didRename.md"


class TextDocumentSyncClientCapabilities(TypedDict):

    # Whether text document synchronization supports dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # The client supports sending will save notifications.
    willSave: NotRequired[bool]

    # The client supports sending a will save request and
    # waits for a response providing text edits which will
    # be applied to the document before it is saved.
    willSaveWaitUntil: NotRequired[bool]

    # The client supports did save notifications.
    didSave: NotRequired[bool]


class TextDocumentSyncOptions(TypedDict):

    # Open and close notifications are sent to the server. If omitted open
    # close notification should not be sent.
    openClose: NotRequired[bool]

    # Change notifications are sent to the server. See
    # TextDocumentSyncKind.None, TextDocumentSyncKind.Full and
    # TextDocumentSyncKind.Incremental. If omitted it defaults to
    # TextDocumentSyncKind.None.
    change: NotRequired[TextDocumentSyncKind]

    # If present will save notifications are sent to the server. If omitted
    # the notification should not be sent.
    willSave: NotRequired[bool]

    # If present will save wait until requests are sent to the server. If
    # omitted the request should not be sent.
    willSaveWaitUntil: NotRequired[bool]

    # If present save notifications are sent to the server. If omitted the
    # notification should not be sent.
    save: NotRequired[Union[bool, SaveOptions]]


# source file: "notebookDocument/notebook.md"

# A notebook document.

# @since 3.17.0


class NotebookDocument(TypedDict):

    # The notebook documentʼs URI.
    uri: URI

    # The type of the notebook.
    notebookType: str

    # The version number of this document (it will increase after each
    # change, including undo/redo).
    version: int

    # Additional metadata stored with the notebook
    # document.
    metadata: NotRequired[LSPObject]

    # The cells of a notebook.
    cells: List['NotebookCell']


# A notebook cell.

# A cellʼs document URI must be unique across ALL notebook
# cells and can therefore be used to uniquely identify a
# notebook cell or the cellʼs text document.

# @since 3.17.0


class NotebookCell(TypedDict):

    # The cellʼs kind
    kind: 'NotebookCellKind'

    # The URI of the cellʼs text document
    # content.
    document: DocumentUri

    # Additional metadata stored with the cell.
    metadata: NotRequired[LSPObject]

    # Additional execution summary information
    # if supported by the client.
    executionSummary: NotRequired['ExecutionSummary']


# A notebook cell kind.

# @since 3.17.0

class NotebookCellKind(IntEnum):

    # A markup-cell is formatted source that is used for display.
    Markup = 1

    # A code-cell is source code.
    Code = 2


class ExecutionSummary(TypedDict):

    # A strict monotonically increasing value
    # indicating the execution order of a cell
    # inside a notebook.
    executionOrder: int

    # Whether the execution was successful or
    # not if known by the client.
    success: NotRequired[bool]


# A notebook cell text document filter denotes a cell text
# document by different properties.

# @since 3.17.0


class NotebookCellTextDocumentFilter(TypedDict):

    # A filter that matches against the notebook
    # containing the notebook cell. If a string
    # value is provided it matches against the
    # notebook type. ʼ*ʼ matches every notebook.
    notebook: Union[str, 'NotebookDocumentFilter']

    # A language id like `python`.

    # Will be matched against the language id of the
    # notebook cell document. ʼ*ʼ matches every language.
    language: NotRequired[str]


# A notebook document filter denotes a notebook document by
# different properties.

# @since 3.17.0

class NotebookDocumentFilter_0(TypedDict):

    # The type of the enclosing notebook.
    notebookType: str

    # A Uri scheme, like `file` or `untitled`.
    scheme: NotRequired[str]

    # A glob pattern.
    pattern: NotRequired[str]
class NotebookDocumentFilter_1(TypedDict):

    # The type of the enclosing notebook.
    notebookType: NotRequired[str]

    # A Uri scheme, like `file` or `untitled`.
    scheme: str

    # A glob pattern.
    pattern: NotRequired[str]
class NotebookDocumentFilter_2(TypedDict):

    # The type of the enclosing notebook.
    notebookType: NotRequired[str]

    # A Uri scheme, like `file` or `untitled`.
    scheme: NotRequired[str]

    # A glob pattern.
    pattern: str
NotebookDocumentFilter = Union[NotebookDocumentFilter_0, NotebookDocumentFilter_1, NotebookDocumentFilter_2]


# Notebook specific client capabilities.

# @since 3.17.0


class NotebookDocumentSyncClientCapabilities(TypedDict):

    # Whether implementation supports dynamic registration. If this is
    # set to `true` the client supports the new
    # `(NotebookDocumentSyncRegistrationOptions & NotebookDocumentSyncOptions)`
    # return value for the corresponding server capability as well.
    dynamicRegistration: NotRequired[bool]

    # The client supports sending execution summary data per cell.
    executionSummarySupport: NotRequired[bool]


# Options specific to a notebook plus its cells
# to be synced to the server.

# If a selector provides a notebook document
# filter but no cell selector all cells of a
# matching notebook document will be synced.

# If a selector provides no notebook document
# filter but only a cell selector all notebook
# documents that contain at least one matching
# cell will be synced.

# @since 3.17.0


class NotebookDocumentSyncOptions(TypedDict):
    class NotebookSelector_0(TypedDict):
        class Cells_0(TypedDict):
            language: str

        # The notebook to be synced. If a string
        # value is provided it matches against the
        # notebook type. ʼ*ʼ matches every notebook.
        notebook: Union[str, NotebookDocumentFilter]

        # The cells of the matching notebook to be synced.
        cells: NotRequired[List[Cells_0]]
    class NotebookSelector_1(TypedDict):
        class Cells_0(TypedDict):
            language: str

        # The notebook to be synced. If a string
        # value is provided it matches against the
        # notebook type. ʼ*ʼ matches every notebook.
        notebook: NotRequired[Union[str, NotebookDocumentFilter]]

        # The cells of the matching notebook to be synced.
        cells: List[Cells_0]

    # The notebooks to be synced
    notebookSelector: List[Union[NotebookSelector_0, NotebookSelector_1]]

    # Whether save notification should be forwarded to
    # the server. Will only be honored if mode === `notebook`.
    save: NotRequired[bool]


# Registration options specific to a notebook.

# @since 3.17.0


class NotebookDocumentSyncRegistrationOptions(NotebookDocumentSyncOptions, StaticRegistrationOptions, TypedDict):
    pass


class DidOpenNotebookDocumentParams(TypedDict):

    # The notebook document that got opened.
    notebookDocument: NotebookDocument

    # The text documents that represent the content
    # of a notebook cell.
    cellTextDocuments: List[TextDocumentItem]


# The params sent in a change notebook document notification.

# @since 3.17.0


class DidChangeNotebookDocumentParams(TypedDict):

    # The notebook document that did change. The version number points
    # to the version after all provided changes have been applied.
    notebookDocument: 'VersionedNotebookDocumentIdentifier'

    # The actual changes to the notebook document.

    # The change describes single state change to the notebook document.
    # So it moves a notebook document, its cells and its cell text document
    # contents from state S to Sʼ.

    # To mirror the content of a notebook using change events use the
    # following approach:
    # - start with the same initial content
    # - apply the ʼnotebookDocument/didChangeʼ notifications in the order
    # you receive them.
    change: 'NotebookDocumentChangeEvent'


# A versioned notebook document identifier.

# @since 3.17.0


class VersionedNotebookDocumentIdentifier(TypedDict):

    # The version number of this notebook document.
    version: int

    # The notebook documentʼs URI.
    uri: URI


# A change event for a notebook document.

# @since 3.17.0


class NotebookDocumentChangeEvent(TypedDict):
    class Cells_0(TypedDict):
        class Structure_0(TypedDict):

            # The change to the cell array.
            array: 'NotebookCellArrayChange'

            # Additional opened cell text documents.
            didOpen: NotRequired[List[TextDocumentItem]]

            # Additional closed cell text documents.
            didClose: NotRequired[List[TextDocumentIdentifier]]
        class TextContent_0(TypedDict):
            document: VersionedTextDocumentIdentifier
            changes: List[TextDocumentContentChangeEvent]

        # Changes to the cell structure to add or
        # remove cells.
        structure: NotRequired[Structure_0]

        # Changes to notebook cells properties like its
        # kind, execution summary or metadata.
        data: NotRequired[List[NotebookCell]]

        # Changes to the text content of notebook cells.
        textContent: NotRequired[List[TextContent_0]]

    # The changed meta data if any.
    metadata: NotRequired[LSPObject]

    # Changes to cells
    cells: NotRequired[Cells_0]


# A change describing how to move a `NotebookCell`
# array from state S to Sʼ.

# @since 3.17.0


class NotebookCellArrayChange(TypedDict):

    # The start offset of the cell that changed.
    start: int

    # The deleted cells
    deleteCount: int

    # The new cells, if any
    cells: NotRequired[List[NotebookCell]]


# The params sent in a save notebook document notification.

# @since 3.17.0


class DidSaveNotebookDocumentParams(TypedDict):

    # The notebook document that got saved.
    notebookDocument: 'NotebookDocumentIdentifier'


# The params sent in a close notebook document notification.

# @since 3.17.0


class DidCloseNotebookDocumentParams(TypedDict):

    # The notebook document that got closed.
    notebookDocument: 'NotebookDocumentIdentifier'

    # The text documents that represent the content
    # of a notebook cell that got closed.
    cellTextDocuments: List[TextDocumentIdentifier]


# A literal to identify a notebook document in the client.

# @since 3.17.0


class NotebookDocumentIdentifier(TypedDict):

    # The notebook documentʼs URI.
    uri: URI


# source file: "language/declaration.md"


class DeclarationClientCapabilities(TypedDict):

    # Whether declaration supports dynamic registration. If this is set to
    # `true` the client supports the new `DeclarationRegistrationOptions`
    # return value for the corresponding server capability as well.
    dynamicRegistration: NotRequired[bool]

    # The client supports additional metadata in the form of declaration links.
    linkSupport: NotRequired[bool]


class DeclarationOptions(WorkDoneProgressOptions, TypedDict):
    pass


class DeclarationRegistrationOptions(DeclarationOptions, TextDocumentRegistrationOptions, StaticRegistrationOptions, TypedDict):
    pass


class DeclarationParams(TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams, TypedDict):
    pass


class DefinitionClientCapabilities(TypedDict):

    # Whether definition supports dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # The client supports additional metadata in the form of definition links.

    # @since 3.14.0
    linkSupport: NotRequired[bool]


class DefinitionOptions(WorkDoneProgressOptions, TypedDict):
    pass


class DefinitionRegistrationOptions(TextDocumentRegistrationOptions, DefinitionOptions, TypedDict):
    pass


class DefinitionParams(TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams, TypedDict):
    pass


class TypeDefinitionClientCapabilities(TypedDict):

    # Whether implementation supports dynamic registration. If this is set to
    # `true` the client supports the new `TypeDefinitionRegistrationOptions`
    # return value for the corresponding server capability as well.
    dynamicRegistration: NotRequired[bool]

    # The client supports additional metadata in the form of definition links.

    # @since 3.14.0
    linkSupport: NotRequired[bool]


class TypeDefinitionOptions(WorkDoneProgressOptions, TypedDict):
    pass


class TypeDefinitionRegistrationOptions(TextDocumentRegistrationOptions, TypeDefinitionOptions, StaticRegistrationOptions, TypedDict):
    pass


class TypeDefinitionParams(TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams, TypedDict):
    pass


class ImplementationClientCapabilities(TypedDict):

    # Whether implementation supports dynamic registration. If this is set to
    # `true` the client supports the new `ImplementationRegistrationOptions`
    # return value for the corresponding server capability as well.
    dynamicRegistration: NotRequired[bool]

    # The client supports additional metadata in the form of definition links.

    # @since 3.14.0
    linkSupport: NotRequired[bool]


class ImplementationOptions(WorkDoneProgressOptions, TypedDict):
    pass


class ImplementationRegistrationOptions(TextDocumentRegistrationOptions, ImplementationOptions, StaticRegistrationOptions, TypedDict):
    pass


class ImplementationParams(TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams, TypedDict):
    pass


class ReferenceClientCapabilities(TypedDict):

    # Whether references supports dynamic registration.
    dynamicRegistration: NotRequired[bool]


class ReferenceOptions(WorkDoneProgressOptions, TypedDict):
    pass


class ReferenceRegistrationOptions(TextDocumentRegistrationOptions, ReferenceOptions, TypedDict):
    pass


class ReferenceParams(TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams, TypedDict):
    context: 'ReferenceContext'


class ReferenceContext(TypedDict):

    # Include the declaration of the current symbol.
    includeDeclaration: bool


# source file: "language/callHierarchy.md"


class CallHierarchyClientCapabilities(TypedDict):

    # Whether implementation supports dynamic registration. If this is set to
    # `true` the client supports the new `(TextDocumentRegistrationOptions &
    # StaticRegistrationOptions)` return value for the corresponding server
    # capability as well.
    dynamicRegistration: NotRequired[bool]


class CallHierarchyOptions(WorkDoneProgressOptions, TypedDict):
    pass


class CallHierarchyRegistrationOptions(TextDocumentRegistrationOptions, CallHierarchyOptions, StaticRegistrationOptions, TypedDict):
    pass


class CallHierarchyPrepareParams(TextDocumentPositionParams, WorkDoneProgressParams, TypedDict):
    pass


class CallHierarchyItem(TypedDict):

    # The name of this item.
    name: str

    # The kind of this item.
    kind: 'SymbolKind'

    # Tags for this item.
    tags: NotRequired[List['SymbolTag']]

    # More detail for this item, e.g. the signature of a function.
    detail: NotRequired[str]

    # The resource identifier of this item.
    uri: DocumentUri

    # The range enclosing this symbol not including leading/trailing whitespace
    # but everything else, e.g. comments and code.
    range: Range

    # The range that should be selected and revealed when this symbol is being
    # picked, e.g. the name of a function. Must be contained by the
    # [`range`](#CallHierarchyItem.range).
    selectionRange: Range

    # A data entry field that is preserved between a call hierarchy prepare and
    # incoming calls or outgoing calls requests.
    data: NotRequired[LSPAny]


class CallHierarchyIncomingCallsParams(WorkDoneProgressParams, PartialResultParams, TypedDict):
    item: CallHierarchyItem


class CallHierarchyIncomingCall(TypedDict):

    # The item that makes the call.
    from_: CallHierarchyItem

    # The ranges at which the calls appear. This is relative to the caller
    # denoted by [`this.from`](#CallHierarchyIncomingCall.from).
    fromRanges: List[Range]


class CallHierarchyOutgoingCallsParams(WorkDoneProgressParams, PartialResultParams, TypedDict):
    item: CallHierarchyItem


class CallHierarchyOutgoingCall(TypedDict):

    # The item that is called.
    to: CallHierarchyItem

    # The range at which this item is called. This is the range relative to
    # the caller, e.g the item passed to `callHierarchy/outgoingCalls` request.
    fromRanges: List[Range]


# source file: "language/typeHierarchy.md"

class TypeHierarchyClientCapabilities_0(TypedDict):

    # Whether implementation supports dynamic registration. If this is set to
    # `true` the client supports the new `(TextDocumentRegistrationOptions &
    # StaticRegistrationOptions)` return value for the corresponding server
    # capability as well.
    dynamicRegistration: NotRequired['bool']
TypeHierarchyClientCapabilities = 'TypeHierarchyClientCapabilities_0'


class TypeHierarchyOptions(WorkDoneProgressOptions, TypedDict):
    pass


class TypeHierarchyRegistrationOptions(TextDocumentRegistrationOptions, TypeHierarchyOptions, StaticRegistrationOptions, TypedDict):
    pass


class TypeHierarchyPrepareParams(TextDocumentPositionParams, WorkDoneProgressParams, TypedDict):
    pass


class TypeHierarchyItem(TypedDict):

    # The name of this item.
    name: str

    # The kind of this item.
    kind: 'SymbolKind'

    # Tags for this item.
    tags: NotRequired[List['SymbolTag']]

    # More detail for this item, e.g. the signature of a function.
    detail: NotRequired[str]

    # The resource identifier of this item.
    uri: DocumentUri

    # The range enclosing this symbol not including leading/trailing whitespace
    # but everything else, e.g. comments and code.
    range: Range

    # The range that should be selected and revealed when this symbol is being
    # picked, e.g. the name of a function. Must be contained by the
    # [`range`](#TypeHierarchyItem.range).
    selectionRange: Range

    # A data entry field that is preserved between a type hierarchy prepare and
    # supertypes or subtypes requests. It could also be used to identify the
    # type hierarchy in the server, helping improve the performance on
    # resolving supertypes and subtypes.
    data: NotRequired[LSPAny]


class TypeHierarchySupertypesParams(WorkDoneProgressParams, PartialResultParams, TypedDict):
    item: TypeHierarchyItem


class TypeHierarchySubtypesParams(WorkDoneProgressParams, PartialResultParams, TypedDict):
    item: TypeHierarchyItem


# source file: "language/documentHighlight.md"


class DocumentHighlightClientCapabilities(TypedDict):

    # Whether document highlight supports dynamic registration.
    dynamicRegistration: NotRequired[bool]


class DocumentHighlightOptions(WorkDoneProgressOptions, TypedDict):
    pass


class DocumentHighlightRegistrationOptions(TextDocumentRegistrationOptions, DocumentHighlightOptions, TypedDict):
    pass


class DocumentHighlightParams(TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams, TypedDict):
    pass


class DocumentHighlight(TypedDict):

    # The range this highlight applies to.
    range: Range

    # The highlight kind, default is DocumentHighlightKind.Text.
    kind: NotRequired['DocumentHighlightKind']


# A document highlight kind.

class DocumentHighlightKind(IntEnum):

    # A textual occurrence.
    Text = 1

    # Read-access of a symbol, like reading a variable.
    Read = 2

    # Write-access of a symbol, like writing to a variable.
    Write = 3

# commented out, because there is already an enumeration with the same name
# DocumentHighlightKind = int


# source file: "language/documentLink.md"


class DocumentLinkClientCapabilities(TypedDict):

    # Whether document link supports dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # Whether the client supports the `tooltip` property on `DocumentLink`.

    # @since 3.15.0
    tooltipSupport: NotRequired[bool]


class DocumentLinkOptions(WorkDoneProgressOptions, TypedDict):

    # Document links have a resolve provider as well.
    resolveProvider: NotRequired[bool]


class DocumentLinkRegistrationOptions(TextDocumentRegistrationOptions, DocumentLinkOptions, TypedDict):
    pass


class DocumentLinkParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The document to provide document links for.
    textDocument: TextDocumentIdentifier


# A document link is a range in a text document that links to an internal or
# external resource, like another text document or a web site.


class DocumentLink(TypedDict):

    # The range this link applies to.
    range: Range

    # The uri this link points to. If missing a resolve request is sent later.
    target: NotRequired[URI]

    # The tooltip text when you hover over this link.

    # If a tooltip is provided, is will be displayed in a string that includes
    # instructions on how to trigger the link, such as `{0} (ctrl + click)`.
    # The specific instructions vary depending on OS, user settings, and
    # localization.

    # @since 3.15.0
    tooltip: NotRequired[str]

    # A data entry field that is preserved on a document link between a
    # DocumentLinkRequest and a DocumentLinkResolveRequest.
    data: NotRequired[LSPAny]


# source file: "language/hover.md"


class HoverClientCapabilities(TypedDict):

    # Whether hover supports dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # Client supports the follow content formats if the content
    # property refers to a `literal of type MarkupContent`.
    # The order describes the preferred format of the client.
    contentFormat: NotRequired[List[MarkupKind]]


class HoverOptions(WorkDoneProgressOptions, TypedDict):
    pass


class HoverRegistrationOptions(TextDocumentRegistrationOptions, HoverOptions, TypedDict):
    pass


class HoverParams(TextDocumentPositionParams, WorkDoneProgressParams, TypedDict):
    pass


class Hover(TypedDict):

    # The hoverʼs content
    contents: Union['MarkedString', List['MarkedString'], MarkupContent]

    # An optional range is a range inside a text document
    # that is used to visualize a hover, e.g. by changing the background color.
    range: NotRequired[Range]


# MarkedString can be used to render human readable text. It is either a
# markdown string or a code-block that provides a language and a code snippet.
# The language identifier is semantically equal to the optional language
# identifier in fenced code blocks in GitHub issues.

# The pair of a language and a value is an equivalent to markdown:
# ```${language}
# ${value}
# ```

# Note that markdown strings will be sanitized - that means html will be
# escaped.

# @deprecated use MarkupContent instead.

class MarkedString_1(TypedDict):
    language: str
    value: str
MarkedString = Union[str, MarkedString_1]


# source file: "language/codeLens.md"


class CodeLensClientCapabilities(TypedDict):

    # Whether code lens supports dynamic registration.
    dynamicRegistration: NotRequired[bool]


class CodeLensOptions(WorkDoneProgressOptions, TypedDict):

    # Code lens has a resolve provider as well.
    resolveProvider: NotRequired[bool]


class CodeLensRegistrationOptions(TextDocumentRegistrationOptions, CodeLensOptions, TypedDict):
    pass


class CodeLensParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The document to request code lens for.
    textDocument: TextDocumentIdentifier


# A code lens represents a command that should be shown along with
# source text, like the number of references, a way to run tests, etc.

# A code lens is _unresolved_ when no command is associated to it. For
# performance reasons the creation of a code lens and resolving should be done
# in two stages.


class CodeLens(TypedDict):

    # The range in which this code lens is valid. Should only span a single
    # line.
    range: Range

    # The command this code lens represents.
    command: NotRequired[Command]

    # A data entry field that is preserved on a code lens item between
    # a code lens and a code lens resolve request.
    data: NotRequired[LSPAny]


class CodeLensWorkspaceClientCapabilities(TypedDict):

    # Whether the client implementation supports a refresh request sent from the
    # server to the client.

    # Note that this event is global and will force the client to refresh all
    # code lenses currently shown. It should be used with absolute care and is
    # useful for situation where a server for example detect a project wide
    # change that requires such a calculation.
    refreshSupport: NotRequired[bool]


# source file: "language/foldingRange.md"


class FoldingRangeClientCapabilities(TypedDict):
    class FoldingRangeKind_0(TypedDict):

        # The folding range kind values the client supports. When this
        # property exists the client also guarantees that it will
        # handle values outside its set gracefully and falls back
        # to a default value when unknown.
        valueSet: NotRequired[List['FoldingRangeKind']]
    class FoldingRange_0(TypedDict):

        # If set, the client signals that it supports setting collapsedText on
        # folding ranges to display custom labels instead of the default text.

        # @since 3.17.0
        collapsedText: NotRequired[bool]

    # Whether implementation supports dynamic registration for folding range
    # providers. If this is set to `true` the client supports the new
    # `FoldingRangeRegistrationOptions` return value for the corresponding
    # server capability as well.
    dynamicRegistration: NotRequired[bool]

    # The maximum number of folding ranges that the client prefers to receive
    # per document. The value serves as a hint, servers are free to follow the
    # limit.
    rangeLimit: NotRequired[int]

    # If set, the client signals that it only supports folding complete lines.
    # If set, client will ignore specified `startCharacter` and `endCharacter`
    # properties in a FoldingRange.
    lineFoldingOnly: NotRequired[bool]

    # Specific options for the folding range kind.

    # @since 3.17.0
    foldingRangeKind: NotRequired[FoldingRangeKind_0]

    # Specific options for the folding range.
    # @since 3.17.0
    foldingRange: NotRequired[FoldingRange_0]


class FoldingRangeOptions(WorkDoneProgressOptions, TypedDict):
    pass


class FoldingRangeRegistrationOptions(TextDocumentRegistrationOptions, FoldingRangeOptions, StaticRegistrationOptions, TypedDict):
    pass


class FoldingRangeParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier


# A set of predefined range kinds.

class FoldingRangeKind(Enum):

    # Folding range for a comment
    Comment = "comment"

    # Folding range for imports or includes
    Imports = "imports"

    # Folding range for a region (e.g. `#region`)
    Region = "region"


# The type is a string since the value set is extensible

# commented out, because there is already an enumeration with the same name
# FoldingRangeKind = str


# Represents a folding range. To be valid, start and end line must be bigger
# than zero and smaller than the number of lines in the document. Clients
# are free to ignore invalid ranges.


class FoldingRange(TypedDict):

    # The zero-based start line of the range to fold. The folded area starts
    # after the lineʼs last character. To be valid, the end must be zero or
    # larger and smaller than the number of lines in the document.
    startLine: int

    # The zero-based character offset from where the folded range starts. If
    # not defined, defaults to the length of the start line.
    startCharacter: NotRequired[int]

    # The zero-based end line of the range to fold. The folded area ends with
    # the lineʼs last character. To be valid, the end must be zero or larger
    # and smaller than the number of lines in the document.
    endLine: int

    # The zero-based character offset before the folded range ends. If not
    # defined, defaults to the length of the end line.
    endCharacter: NotRequired[int]

    # Describes the kind of the folding range such as `comment` or `region`.
    # The kind is used to categorize folding ranges and used by commands like
    # ʼFold all commentsʼ. See [FoldingRangeKind](#FoldingRangeKind) for an
    # enumeration of standardized kinds.
    kind: NotRequired[FoldingRangeKind]

    # The text that the client should show when the specified range is
    # collapsed. If not defined or not supported by the client, a default
    # will be chosen by the client.

    # @since 3.17.0 - proposed
    collapsedText: NotRequired[str]


# source file: "language/selectionRange.md"


class SelectionRangeClientCapabilities(TypedDict):

    # Whether implementation supports dynamic registration for selection range
    # providers. If this is set to `true` the client supports the new
    # `SelectionRangeRegistrationOptions` return value for the corresponding
    # server capability as well.
    dynamicRegistration: NotRequired[bool]


class SelectionRangeOptions(WorkDoneProgressOptions, TypedDict):
    pass


class SelectionRangeRegistrationOptions(SelectionRangeOptions, TextDocumentRegistrationOptions, StaticRegistrationOptions, TypedDict):
    pass


class SelectionRangeParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier

    # The positions inside the text document.
    positions: List[Position]


class SelectionRange(TypedDict):

    # The [range](#Range) of this selection range.
    range: Range

    # The parent selection range containing this range. Therefore
    # `parent.range` must contain `this.range`.
    parent: NotRequired['SelectionRange']


# source file: "language/documentSymbol.md"


class DocumentSymbolClientCapabilities(TypedDict):
    class SymbolKind_0(TypedDict):

        # The symbol kind values the client supports. When this
        # property exists the client also guarantees that it will
        # handle values outside its set gracefully and falls back
        # to a default value when unknown.

        # If this property is not present the client only supports
        # the symbol kinds from `File` to `Array` as defined in
        # the initial version of the protocol.
        valueSet: NotRequired[List['SymbolKind']]
    class TagSupport_0(TypedDict):

        # The tags supported by the client.
        valueSet: List['SymbolTag']

    # Whether document symbol supports dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # Specific capabilities for the `SymbolKind` in the
    # `textDocument/documentSymbol` request.
    symbolKind: NotRequired[SymbolKind_0]

    # The client supports hierarchical document symbols.
    hierarchicalDocumentSymbolSupport: NotRequired[bool]

    # The client supports tags on `SymbolInformation`. Tags are supported on
    # `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
    # Clients supporting tags have to handle unknown tags gracefully.

    # @since 3.16.0
    tagSupport: NotRequired[TagSupport_0]

    # The client supports an additional label presented in the UI when
    # registering a document symbol provider.

    # @since 3.16.0
    labelSupport: NotRequired[bool]


class DocumentSymbolOptions(WorkDoneProgressOptions, TypedDict):

    # A human-readable string that is shown when multiple outlines trees
    # are shown for the same document.

    # @since 3.16.0
    label: NotRequired[str]


class DocumentSymbolRegistrationOptions(TextDocumentRegistrationOptions, DocumentSymbolOptions, TypedDict):
    pass


class DocumentSymbolParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier


# A symbol kind.

class SymbolKind(IntEnum):
    File = 1
    Module = 2
    Namespace = 3
    Package = 4
    Class = 5
    Method = 6
    Property = 7
    Field = 8
    Constructor = 9
    Enum = 10
    Interface = 11
    Function = 12
    Variable = 13
    Constant = 14
    String = 15
    Number = 16
    Boolean = 17
    Array = 18
    Object = 19
    Key = 20
    Null = 21
    EnumMember = 22
    Struct = 23
    Event = 24
    Operator = 25
    TypeParameter = 26

# commented out, because there is already an enumeration with the same name
# SymbolKind = int


# Symbol tags are extra annotations that tweak the rendering of a symbol.

# @since 3.16

class SymbolTag(IntEnum):

    # Render a symbol as obsolete, usually using a strike-out.
    Deprecated = 1

# commented out, because there is already an enumeration with the same name
# SymbolTag = int


# Represents programming constructs like variables, classes, interfaces etc.
# that appear in a document. Document symbols can be hierarchical and they
# have two ranges: one that encloses its definition and one that points to its
# most interesting range, e.g. the range of an identifier.


class DocumentSymbol(TypedDict):

    # The name of this symbol. Will be displayed in the user interface and
    # therefore must not be an empty string or a string only consisting of
    # white spaces.
    name: str

    # More detail for this symbol, e.g the signature of a function.
    detail: NotRequired[str]

    # The kind of this symbol.
    kind: SymbolKind

    # Tags for this document symbol.

    # @since 3.16.0
    tags: NotRequired[List[SymbolTag]]

    # Indicates if this symbol is deprecated.

    # @deprecated Use tags instead
    deprecated: NotRequired[bool]

    # The range enclosing this symbol not including leading/trailing whitespace
    # but everything else like comments. This information is typically used to
    # determine if the clients cursor is inside the symbol to reveal it  in the
    # UI.
    range: Range

    # The range that should be selected and revealed when this symbol is being
    # picked, e.g. the name of a function. Must be contained by the `range`.
    selectionRange: Range

    # Children of this symbol, e.g. properties of a class.
    children: NotRequired[List['DocumentSymbol']]


# Represents information about programming constructs like variables, classes,
# interfaces etc.

# @deprecated use DocumentSymbol or WorkspaceSymbol instead.


class SymbolInformation(TypedDict):

    # The name of this symbol.
    name: str

    # The kind of this symbol.
    kind: SymbolKind

    # Tags for this symbol.

    # @since 3.16.0
    tags: NotRequired[List[SymbolTag]]

    # Indicates if this symbol is deprecated.

    # @deprecated Use tags instead
    deprecated: NotRequired[bool]

    # The location of this symbol. The locationʼs range is used by a tool
    # to reveal the location in the editor. If the symbol is selected in the
    # tool the rangeʼs start information is used to position the cursor. So
    # the range usually spans more then the actual symbolʼs name and does
    # normally include things like visibility modifiers.

    # The range doesnʼt have to denote a node range in the sense of an abstract
    # syntax tree. It can therefore not be used to re-construct a hierarchy of
    # the symbols.
    location: Location

    # The name of the symbol containing this symbol. This information is for
    # user interface purposes (e.g. to render a qualifier in the user interface
    # if necessary). It canʼt be used to re-infer a hierarchy for the document
    # symbols.
    containerName: NotRequired[str]


# source file: "language/semanticTokens.md"

class SemanticTokenTypes(Enum):
    namespace = "namespace"
    type = "type"
    class_ = "class"
    enum = "enum"
    interface = "interface"
    struct = "struct"
    typeParameter = "typeParameter"
    parameter = "parameter"
    variable = "variable"
    property = "property"
    enumMember = "enumMember"
    event = "event"
    function = "function"
    method = "method"
    macro = "macro"
    keyword = "keyword"
    modifier = "modifier"
    comment = "comment"
    string = "string"
    number = "number"
    regexp = "regexp"
    operator = "operator"
    decorator = "decorator"

class SemanticTokenModifiers(Enum):
    declaration = "declaration"
    definition = "definition"
    readonly = "readonly"
    static = "static"
    deprecated = "deprecated"
    abstract = "abstract"
    async_ = "async"
    modification = "modification"
    documentation = "documentation"
    defaultLibrary = "defaultLibrary"

class TokenFormat(Enum):
    Relative = "relative"

# commented out, because there is already an enumeration with the same name
# TokenFormat = str


class SemanticTokensLegend(TypedDict):

    # The token types a server uses.
    tokenTypes: List[str]

    # The token modifiers a server uses.
    tokenModifiers: List[str]


class SemanticTokensClientCapabilities(TypedDict):
    class Requests_0(TypedDict):
        class Range_1(TypedDict):
            pass
        class Full_1(TypedDict):

            # The client will send the `textDocument/semanticTokens/full/delta`
            # request if the server provides a corresponding handler.
            delta: NotRequired[bool]

        # The client will send the `textDocument/semanticTokens/range` request
        # if the server provides a corresponding handler.
        range: NotRequired[Union[bool, Range_1]]

        # The client will send the `textDocument/semanticTokens/full` request
        # if the server provides a corresponding handler.
        full: NotRequired[Union[bool, Full_1]]

    # Whether implementation supports dynamic registration. If this is set to
    # `true` the client supports the new `(TextDocumentRegistrationOptions &
    # StaticRegistrationOptions)` return value for the corresponding server
    # capability as well.
    dynamicRegistration: NotRequired[bool]

    # Which requests the client supports and might send to the server
    # depending on the serverʼs capability. Please note that clients might not
    # show semantic tokens or degrade some of the user experience if a range
    # or full request is advertised by the client but not provided by the
    # server. If for example the client capability `requests.full` and
    # `request.range` are both set to true but the server only provides a
    # range provider the client might not render a minimap correctly or might
    # even decide to not show any semantic tokens at all.
    requests: Requests_0

    # The token types that the client supports.
    tokenTypes: List[str]

    # The token modifiers that the client supports.
    tokenModifiers: List[str]

    # The formats the clients supports.
    formats: List[TokenFormat]

    # Whether the client supports tokens that can overlap each other.
    overlappingTokenSupport: NotRequired[bool]

    # Whether the client supports tokens that can span multiple lines.
    multilineTokenSupport: NotRequired[bool]

    # Whether the client allows the server to actively cancel a
    # semantic token request, e.g. supports returning
    # ErrorCodes.ServerCancelled. If a server does the client
    # needs to retrigger the request.

    # @since 3.17.0
    serverCancelSupport: NotRequired[bool]

    # Whether the client uses semantic tokens to augment existing
    # syntax tokens. If set to `true` client side created syntax
    # tokens and semantic tokens are both used for colorization. If
    # set to `false` the client only uses the returned semantic tokens
    # for colorization.

    # If the value is `undefined` then the client behavior is not
    # specified.

    # @since 3.17.0
    augmentsSyntaxTokens: NotRequired[bool]


class SemanticTokensOptions(WorkDoneProgressOptions, TypedDict):
    class Range_1(TypedDict):
        pass
    class Full_1(TypedDict):

        # The server supports deltas for full documents.
        delta: NotRequired[bool]

    # The legend used by the server
    legend: SemanticTokensLegend

    # Server supports providing semantic tokens for a specific range
    # of a document.
    range: NotRequired[Union[bool, Range_1]]

    # Server supports providing semantic tokens for a full document.
    full: NotRequired[Union[bool, Full_1]]


class SemanticTokensRegistrationOptions(TextDocumentRegistrationOptions, SemanticTokensOptions, StaticRegistrationOptions, TypedDict):
    pass


class SemanticTokensParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier


class SemanticTokens(TypedDict):

    # An optional result id. If provided and clients support delta updating
    # the client will include the result id in the next semantic token request.
    # A server can then instead of computing all semantic tokens again simply
    # send a delta.
    resultId: NotRequired[str]

    # The actual tokens.
    data: List[int]


class SemanticTokensPartialResult(TypedDict):
    data: List[int]


class SemanticTokensDeltaParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier

    # The result id of a previous response. The result Id can either point to
    # a full response or a delta response depending on what was received last.
    previousResultId: str


class SemanticTokensDelta(TypedDict):
    resultId: NotRequired[ReadOnly[str]]

    # The semantic token edits to transform a previous result into a new
    # result.
    edits: List['SemanticTokensEdit']


class SemanticTokensEdit(TypedDict):

    # The start offset of the edit.
    start: int

    # The count of elements to remove.
    deleteCount: int

    # The elements to insert.
    data: NotRequired[List[int]]


class SemanticTokensDeltaPartialResult(TypedDict):
    edits: List[SemanticTokensEdit]


class SemanticTokensRangeParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier

    # The range the semantic tokens are requested for.
    range: Range


class SemanticTokensWorkspaceClientCapabilities(TypedDict):

    # Whether the client implementation supports a refresh request sent from
    # the server to the client.

    # Note that this event is global and will force the client to refresh all
    # semantic tokens currently shown. It should be used with absolute care
    # and is useful for situation where a server for example detect a project
    # wide change that requires such a calculation.
    refreshSupport: NotRequired[bool]


# source file: "language/inlayHint.md"

# Inlay hint client capabilities.

# @since 3.17.0


class InlayHintClientCapabilities(TypedDict):
    class ResolveSupport_0(TypedDict):

        # The properties that a client can resolve lazily.
        properties: List[str]

    # Whether inlay hints support dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # Indicates which properties a client can resolve lazily on an inlay
    # hint.
    resolveSupport: NotRequired[ResolveSupport_0]


# Inlay hint options used during static registration.

# @since 3.17.0


class InlayHintOptions(WorkDoneProgressOptions, TypedDict):

    # The server provides support to resolve additional
    # information for an inlay hint item.
    resolveProvider: NotRequired[bool]


# Inlay hint options used during static or dynamic registration.

# @since 3.17.0


class InlayHintRegistrationOptions(InlayHintOptions, TextDocumentRegistrationOptions, StaticRegistrationOptions, TypedDict):
    pass


class InlayHintParams(WorkDoneProgressParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier

    # The visible document range for which inlay hints should be computed.
    range: Range


# Inlay hint information.

# @since 3.17.0


class InlayHint(TypedDict):

    # The position of this hint.

    # If multiple hints have the same position, they will be shown in the order
    # they appear in the response.
    position: Position

    # The label of this hint. A human readable string or an array of
    # InlayHintLabelPart label parts.

    # *Note* that neither the string nor the label part can be empty.
    label: Union[str, List['InlayHintLabelPart']]

    # The kind of this hint. Can be omitted in which case the client
    # should fall back to a reasonable default.
    kind: NotRequired['InlayHintKind']

    # Optional text edits that are performed when accepting this inlay hint.

    # *Note* that edits are expected to change the document so that the inlay
    # hint (or its nearest variant) is now part of the document and the inlay
    # hint itself is now obsolete.

    # Depending on the client capability `inlayHint.resolveSupport` clients
    # might resolve this property late using the resolve request.
    textEdits: NotRequired[List[TextEdit]]

    # The tooltip text when you hover over this item.

    # Depending on the client capability `inlayHint.resolveSupport` clients
    # might resolve this property late using the resolve request.
    tooltip: NotRequired[Union[str, MarkupContent]]

    # Render padding before the hint.

    # Note: Padding should use the editorʼs background color, not the
    # background color of the hint itself. That means padding can be used
    # to visually align/separate an inlay hint.
    paddingLeft: NotRequired[bool]

    # Render padding after the hint.

    # Note: Padding should use the editorʼs background color, not the
    # background color of the hint itself. That means padding can be used
    # to visually align/separate an inlay hint.
    paddingRight: NotRequired[bool]

    # A data entry field that is preserved on an inlay hint between
    # a `textDocument/inlayHint` and a `inlayHint/resolve` request.
    data: NotRequired[LSPAny]


# An inlay hint label part allows for interactive and composite labels
# of inlay hints.

# @since 3.17.0


class InlayHintLabelPart(TypedDict):

    # The value of this label part.
    value: str

    # The tooltip text when you hover over this label part. Depending on
    # the client capability `inlayHint.resolveSupport` clients might resolve
    # this property late using the resolve request.
    tooltip: NotRequired[Union[str, MarkupContent]]

    # An optional source code location that represents this
    # label part.

    # The editor will use this location for the hover and for code navigation
    # features: This part will become a clickable link that resolves to the
    # definition of the symbol at the given location (not necessarily the
    # location itself), it shows the hover that shows at the given location,
    # and it shows a context menu with further code navigation commands.

    # Depending on the client capability `inlayHint.resolveSupport` clients
    # might resolve this property late using the resolve request.
    location: NotRequired[Location]

    # An optional command for this label part.

    # Depending on the client capability `inlayHint.resolveSupport` clients
    # might resolve this property late using the resolve request.
    command: NotRequired[Command]


# Inlay hint kinds.

# @since 3.17.0

class InlayHintKind(IntEnum):

    # An inlay hint that for a type annotation.
    Type = 1

    # An inlay hint that is for a parameter.
    Parameter = 2

# commented out, because there is already an enumeration with the same name
# InlayHintKind = int


class InlayHintWorkspaceClientCapabilities(TypedDict):

    # Whether the client implementation supports a refresh request sent from
    # the server to the client.

    # Note that this event is global and will force the client to refresh all
    # inlay hints currently shown. It should be used with absolute care and
    # is useful for situation where a server for example detects a project wide
    # change that requires such a calculation.
    refreshSupport: NotRequired[bool]


# source file: "language/inlineValue.md"

# Client capabilities specific to inline values.

# @since 3.17.0


class InlineValueClientCapabilities(TypedDict):

    # Whether implementation supports dynamic registration for inline
    # value providers.
    dynamicRegistration: NotRequired[bool]


# Inline value options used during static registration.

# @since 3.17.0


class InlineValueOptions(WorkDoneProgressOptions, TypedDict):
    pass


class InlineValueRegistrationOptions(InlineValueOptions, TextDocumentRegistrationOptions, StaticRegistrationOptions, TypedDict):
    pass


class InlineValueParams(WorkDoneProgressParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier

    # The document range for which inline values should be computed.
    range: Range

    # Additional information about the context in which inline values were
    # requested.
    context: 'InlineValueContext'


# @since 3.17.0


class InlineValueContext(TypedDict):

    # The stack frame (as a DAP Id) where the execution has stopped.
    frameId: int

    # The document range where execution has stopped.
    # Typically the end position of the range denotes the line where the
    # inline values are shown.
    stoppedLocation: Range


# Provide inline value as text.

# @since 3.17.0


class InlineValueText(TypedDict):

    # The document range for which the inline value applies.
    range: Range

    # The text of the inline value.
    text: str


# Provide inline value through a variable lookup.

# If only a range is specified, the variable name will be extracted from
# the underlying document.

# An optional variable name can be used to override the extracted name.

# @since 3.17.0


class InlineValueVariableLookup(TypedDict):

    # The document range for which the inline value applies.
    # The range is used to extract the variable name from the underlying
    # document.
    range: Range

    # If specified the name of the variable to look up.
    iableName: NotRequired[str]

    # How to perform the lookup.
    caseSensitiveLookup: bool


# Provide an inline value through an expression evaluation.

# If only a range is specified, the expression will be extracted from the
# underlying document.

# An optional expression can be used to override the extracted expression.

# @since 3.17.0


class InlineValueEvaluatableExpression(TypedDict):

    # The document range for which the inline value applies.
    # The range is used to extract the evaluatable expression from the
    # underlying document.
    range: Range

    # If specified the expression overrides the extracted expression.
    expression: NotRequired[str]


# Inline value information can be provided by different means:
# - directly as a text value (class InlineValueText).
# - as a name to use for a variable lookup (class InlineValueVariableLookup)
# - as an evaluatable expression (class InlineValueEvaluatableExpression)
# The InlineValue types combines all inline value types into one type.

# @since 3.17.0

InlineValue = Union[InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression]


# Client workspace capabilities specific to inline values.

# @since 3.17.0


class InlineValueWorkspaceClientCapabilities(TypedDict):

    # Whether the client implementation supports a refresh request sent from
    # the server to the client.

    # Note that this event is global and will force the client to refresh all
    # inline values currently shown. It should be used with absolute care and
    # is useful for situation where a server for example detect a project wide
    # change that requires such a calculation.
    refreshSupport: NotRequired[bool]


# source file: "language/moniker.md"


class MonikerClientCapabilities(TypedDict):

    # Whether implementation supports dynamic registration. If this is set to
    # `true` the client supports the new `(TextDocumentRegistrationOptions &
    # StaticRegistrationOptions)` return value for the corresponding server
    # capability as well.
    dynamicRegistration: NotRequired[bool]


class MonikerOptions(WorkDoneProgressOptions, TypedDict):
    pass


class MonikerRegistrationOptions(TextDocumentRegistrationOptions, MonikerOptions, TypedDict):
    pass


class MonikerParams(TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams, TypedDict):
    pass

class UniquenessLevel(Enum):
    document = "document"
    project = "project"
    group = "group"
    scheme = "scheme"
    global_ = "global"


# The moniker kind.

class MonikerKind(Enum):
    import_ = "import"
    export = "export"
    local = "local"


# Moniker definition to match LSIF 0.5 moniker definition.


class Moniker(TypedDict):

    # The scheme of the moniker. For example tsc or .Net
    scheme: str

    # The identifier of the moniker. The value is opaque in LSIF however
    # schema owners are allowed to define the structure if they want.
    identifier: str

    # The scope in which the moniker is unique
    unique: UniquenessLevel

    # The moniker kind if known.
    kind: NotRequired[MonikerKind]


# source file: "language/completion.md"


class CompletionClientCapabilities(TypedDict):
    class CompletionItem_0(TypedDict):
        class TagSupport_0(TypedDict):

            # The tags supported by the client.
            valueSet: List['CompletionItemTag']
        class ResolveSupport_0(TypedDict):

            # The properties that a client can resolve lazily.
            properties: List[str]
        class InsertTextModeSupport_0(TypedDict):
            valueSet: List['InsertTextMode']

        # Client supports snippets as insert text.

        # A snippet can define tab stops and placeholders with `$1`, `$2`
        # and `${3:foo}`. `$0` defines the final tab stop, it defaults to
        # the end of the snippet. Placeholders with equal identifiers are
        # linked, that is typing in one will update others too.
        snippetSupport: NotRequired[bool]

        # Client supports commit characters on a completion item.
        commitCharactersSupport: NotRequired[bool]

        # Client supports the follow content formats for the documentation
        # property. The order describes the preferred format of the client.
        documentationFormat: NotRequired[List[MarkupKind]]

        # Client supports the deprecated property on a completion item.
        deprecatedSupport: NotRequired[bool]

        # Client supports the preselect property on a completion item.
        preselectSupport: NotRequired[bool]

        # Client supports the tag property on a completion item. Clients
        # supporting tags have to handle unknown tags gracefully. Clients
        # especially need to preserve unknown tags when sending a completion
        # item back to the server in a resolve call.

        # @since 3.15.0
        tagSupport: NotRequired[TagSupport_0]

        # Client supports insert replace edit to control different behavior if
        # a completion item is inserted in the text or should replace text.

        # @since 3.16.0
        insertReplaceSupport: NotRequired[bool]

        # Indicates which properties a client can resolve lazily on a
        # completion item. Before version 3.16.0 only the predefined properties
        # `documentation` and `detail` could be resolved lazily.

        # @since 3.16.0
        resolveSupport: NotRequired[ResolveSupport_0]

        # The client supports the `insertTextMode` property on
        # a completion item to override the whitespace handling mode
        # as defined by the client (see `insertTextMode`).

        # @since 3.16.0
        insertTextModeSupport: NotRequired[InsertTextModeSupport_0]

        # The client has support for completion item label
        # details (see also `CompletionItemLabelDetails`).

        # @since 3.17.0
        labelDetailsSupport: NotRequired[bool]
    class CompletionItemKind_0(TypedDict):

        # The completion item kind values the client supports. When this
        # property exists the client also guarantees that it will
        # handle values outside its set gracefully and falls back
        # to a default value when unknown.

        # If this property is not present the client only supports
        # the completion items kinds from `Text` to `Reference` as defined in
        # the initial version of the protocol.
        valueSet: NotRequired[List['CompletionItemKind']]
    class CompletionList_0(TypedDict):

        # The client supports the following itemDefaults on
        # a completion list.

        # The value lists the supported property names of the
        # `CompletionList.itemDefaults` object. If omitted
        # no properties are supported.

        # @since 3.17.0
        itemDefaults: NotRequired[List[str]]

    # Whether completion supports dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # The client supports the following `CompletionItem` specific
    # capabilities.
    completionItem: NotRequired[CompletionItem_0]
    completionItemKind: NotRequired[CompletionItemKind_0]

    # The client supports to send additional context information for a
    # `textDocument/completion` request.
    contextSupport: NotRequired[bool]

    # The clientʼs default when the completion item doesnʼt provide a
    # `insertTextMode` property.

    # @since 3.17.0
    insertTextMode: NotRequired['InsertTextMode']

    # The client supports the following `CompletionList` specific
    # capabilities.

    # @since 3.17.0
    completionList: NotRequired[CompletionList_0]


# Completion options.


class CompletionOptions(WorkDoneProgressOptions, TypedDict):
    class CompletionItem_0(TypedDict):

        # The server has support for completion item label
        # details (see also `CompletionItemLabelDetails`) when receiving
        # a completion item in a resolve call.

        # @since 3.17.0
        labelDetailsSupport: NotRequired[bool]

    # The additional characters, beyond the defaults provided by the client (typically
    # [a-zA-Z]), that should automatically trigger a completion request. For example
    # `.` in JavaScript represents the beginning of an object property or method and is
    # thus a good candidate for triggering a completion request.

    # Most tools trigger a completion request automatically without explicitly
    # requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically they
    # do so when the user starts to type an identifier. For example if the user
    # types `c` in a JavaScript file code complete will automatically pop up
    # present `console` besides others as a completion item. Characters that
    # make up identifiers donʼt need to be listed here.
    triggerCharacters: NotRequired[List[str]]

    # The list of all possible characters that commit a completion. This field
    # can be used if clients donʼt support individual commit characters per
    # completion item. See client capability
    # `completion.completionItem.commitCharactersSupport`.

    # If a server provides both `allCommitCharacters` and commit characters on
    # an individual completion item the ones on the completion item win.

    # @since 3.2.0
    allCommitCharacters: NotRequired[List[str]]

    # The server provides support to resolve additional
    # information for a completion item.
    resolveProvider: NotRequired[bool]

    # The server supports the following `CompletionItem` specific
    # capabilities.

    # @since 3.17.0
    completionItem: NotRequired[CompletionItem_0]


class CompletionRegistrationOptions(TextDocumentRegistrationOptions, CompletionOptions, TypedDict):
    pass


class CompletionParams(TextDocumentPositionParams, WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The completion context. This is only available if the client specifies
    # to send this using the client capability
    # `completion.contextSupport === true`
    context: NotRequired['CompletionContext']


# How a completion was triggered

class CompletionTriggerKind(IntEnum):

    # Completion was triggered by typing an identifier (24x7 code
    # complete), manual invocation (e.g Ctrl+Space) or via API.
    Invoked = 1

    # Completion was triggered by a trigger character specified by
    # the `triggerCharacters` properties of the
    # `CompletionRegistrationOptions`.
    TriggerCharacter = 2

    # Completion was re-triggered as the current completion list is incomplete.
    TriggerForIncompleteCompletions = 3

# commented out, because there is already an enumeration with the same name
# CompletionTriggerKind = int


# Contains additional information about the context in which a completion
# request is triggered.


class CompletionContext(TypedDict):

    # How the completion was triggered.
    triggerKind: CompletionTriggerKind

    # The trigger character (a single character) that has trigger code
    # complete. Is undefined if
    # `triggerKind !== CompletionTriggerKind.TriggerCharacter`
    triggerCharacter: NotRequired[str]


# Represents a collection of [completion items](#CompletionItem) to be
# presented in the editor.


class CompletionList(TypedDict):
    class ItemDefaults_0(TypedDict):
        class EditRange_1(TypedDict):
            insert: Range
            replace: Range

        # A default commit character set.

        # @since 3.17.0
        commitCharacters: NotRequired[List[str]]

        # A default edit range

        # @since 3.17.0
        editRange: NotRequired[Union[Range, EditRange_1]]

        # A default insert text format

        # @since 3.17.0
        insertTextFormat: NotRequired['InsertTextFormat']

        # A default insert text mode

        # @since 3.17.0
        insertTextMode: NotRequired['InsertTextMode']

        # A default data value.

        # @since 3.17.0
        data: NotRequired[LSPAny]

    # This list is not complete. Further typing should result in recomputing
    # this list.

    # Recomputed lists have all their items replaced (not appended) in the
    # incomplete completion sessions.
    isIncomplete: bool

    # In many cases the items of an actual completion result share the same
    # value for properties like `commitCharacters` or the range of a text
    # edit. A completion list can therefore define item defaults which will
    # be used if a completion item itself doesnʼt specify the value.

    # If a completion list specifies a default value and a completion item
    # also specifies a corresponding value the one from the item is used.

    # Servers are only allowed to return default values if the client
    # signals support for this via the `completionList.itemDefaults`
    # capability.

    # @since 3.17.0
    itemDefaults: NotRequired[ItemDefaults_0]

    # The completion items.
    items: List['CompletionItem']


# Defines whether the insert text in a completion item should be interpreted as
# plain text or a snippet.

class InsertTextFormat(IntEnum):

    # The primary text to be inserted is treated as a plain string.
    PlainText = 1

    # The primary text to be inserted is treated as a snippet.

    # A snippet can define tab stops and placeholders with `$1`, `$2`
    # and `${3:foo}`. `$0` defines the final tab stop, it defaults to
    # the end of the snippet. Placeholders with equal identifiers are linked,
    # that is typing in one will update others too.
    Snippet = 2

# commented out, because there is already an enumeration with the same name
# InsertTextFormat = int


# Completion item tags are extra annotations that tweak the rendering of a
# completion item.

# @since 3.15.0

class CompletionItemTag(IntEnum):

    # Render a completion as obsolete, usually using a strike-out.
    Deprecated = 1

# commented out, because there is already an enumeration with the same name
# CompletionItemTag = int


# A special text edit to provide an insert and a replace operation.

# @since 3.16.0


class InsertReplaceEdit(TypedDict):

    # The string to be inserted.
    newText: str

    # The range if the insert is requested
    insert: Range

    # The range if the replace is requested.
    replace: Range


# How whitespace and indentation is handled during completion
# item insertion.

# @since 3.16.0

class InsertTextMode(IntEnum):

    # The insertion or replace strings is taken as it is. If the
    # value is multi line the lines below the cursor will be
    # inserted using the indentation defined in the string value.
    # The client will not apply any kind of adjustments to the
    # string.
    asIs = 1

    # The editor adjusts leading whitespace of new lines so that
    # they match the indentation up to the cursor of the line for
    # which the item is accepted.

    # Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
    # multi line completion item is indented using 2 tabs and all
    # following lines inserted will be indented using 2 tabs as well.
    adjustIndentation = 2

# commented out, because there is already an enumeration with the same name
# InsertTextMode = int


# Additional details for a completion item label.

# @since 3.17.0


class CompletionItemLabelDetails(TypedDict):

    # An optional string which is rendered less prominently directly after
    # {@link CompletionItem.label label}, without any spacing. Should be
    # used for function signatures or type annotations.
    detail: NotRequired[str]

    # An optional string which is rendered less prominently after
    # {@link CompletionItemLabelDetails.detail}. Should be used for fully qualified
    # names or file path.
    description: NotRequired[str]


class CompletionItem(TypedDict):

    # The label of this completion item.

    # The label property is also by default the text that
    # is inserted when selecting this completion.

    # If label details are provided the label itself should
    # be an unqualified name of the completion item.
    label: str

    # Additional details for the label

    # @since 3.17.0
    labelDetails: NotRequired[CompletionItemLabelDetails]

    # The kind of this completion item. Based of the kind
    # an icon is chosen by the editor. The standardized set
    # of available values is defined in `CompletionItemKind`.
    kind: NotRequired['CompletionItemKind']

    # Tags for this completion item.

    # @since 3.15.0
    tags: NotRequired[List[CompletionItemTag]]

    # A human-readable string with additional information
    # about this item, like type or symbol information.
    detail: NotRequired[str]

    # A human-readable string that represents a doc-comment.
    documentation: NotRequired[Union[str, MarkupContent]]

    # Indicates if this item is deprecated.

    # @deprecated Use `tags` instead if supported.
    deprecated: NotRequired[bool]

    # Select this item when showing.

    # *Note* that only one completion item can be selected and that the
    # tool / client decides which item that is. The rule is that the *first*
    # item of those that match best is selected.
    preselect: NotRequired[bool]

    # A string that should be used when comparing this item
    # with other items. When omitted the label is used
    # as the sort text for this item.
    sortText: NotRequired[str]

    # A string that should be used when filtering a set of
    # completion items. When omitted the label is used as the
    # filter text for this item.
    filterText: NotRequired[str]

    # A string that should be inserted into a document when selecting
    # this completion. When omitted the label is used as the insert text
    # for this item.

    # The `insertText` is subject to interpretation by the client side.
    # Some tools might not take the string literally. For example
    # VS Code when code complete is requested in this example
    # `con<cursor position>` and a completion item with an `insertText` of
    # `console` is provided it will only insert `sole`. Therefore it is
    # recommended to use `textEdit` instead since it avoids additional client
    # side interpretation.
    insertText: NotRequired[str]

    # The format of the insert text. The format applies to both the
    # `insertText` property and the `newText` property of a provided
    # `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.

    # Please note that the insertTextFormat doesnʼt apply to
    # `additionalTextEdits`.
    insertTextFormat: NotRequired[InsertTextFormat]

    # How whitespace and indentation is handled during completion
    # item insertion. If not provided the clientʼs default value depends on
    # the `textDocument.completion.insertTextMode` client capability.

    # @since 3.16.0
    # @since 3.17.0 - support for `textDocument.completion.insertTextMode`
    insertTextMode: NotRequired[InsertTextMode]

    # An edit which is applied to a document when selecting this completion.
    # When an edit is provided the value of `insertText` is ignored.

    # *Note:* The range of the edit must be a single line range and it must
    # contain the position at which completion has been requested.

    # Most editors support two different operations when accepting a completion
    # item. One is to insert a completion text and the other is to replace an
    # existing text with a completion text. Since this can usually not be
    # predetermined by a server it can report both ranges. Clients need to
    # signal support for `InsertReplaceEdit`s via the
    # `textDocument.completion.completionItem.insertReplaceSupport` client
    # capability property.

    # *Note 1:* The text editʼs range as well as both ranges from an insert
    # replace edit must be a [single line] and they must contain the position
    # at which completion has been requested.
    # *Note 2:* If an `InsertReplaceEdit` is returned the editʼs insert range
    # must be a prefix of the editʼs replace range, that means it must be
    # contained and starting at the same position.

    # @since 3.16.0 additional type `InsertReplaceEdit`
    textEdit: NotRequired[Union[TextEdit, InsertReplaceEdit]]

    # The edit text used if the completion item is part of a CompletionList and
    # CompletionList defines an item default for the text edit range.

    # Clients will only honor this property if they opt into completion list
    # item defaults using the capability `completionList.itemDefaults`.

    # If not provided and a listʼs default range is provided the label
    # property is used as a text.

    # @since 3.17.0
    textEditText: NotRequired[str]

    # An optional array of additional text edits that are applied when
    # selecting this completion. Edits must not overlap (including the same
    # insert position) with the main edit nor with themselves.

    # Additional text edits should be used to change text unrelated to the
    # current cursor position (for example adding an import statement at the
    # top of the file if the completion item will insert an unqualified type).
    additionalTextEdits: NotRequired[List[TextEdit]]

    # An optional set of characters that when pressed while this completion is
    # active will accept it first and then type that character. *Note* that all
    # commit characters should have `length=1` and that superfluous characters
    # will be ignored.
    commitCharacters: NotRequired[List[str]]

    # An optional command that is executed *after* inserting this completion.
    # *Note* that additional modifications to the current document should be
    # described with the additionalTextEdits-property.
    command: NotRequired[Command]

    # A data entry field that is preserved on a completion item between
    # a completion and a completion resolve request.
    data: NotRequired[LSPAny]


# The kind of a completion entry.

class CompletionItemKind(IntEnum):
    Text = 1
    Method = 2
    Function = 3
    Constructor = 4
    Field = 5
    Variable = 6
    Class = 7
    Interface = 8
    Module = 9
    Property = 10
    Unit = 11
    Value = 12
    Enum = 13
    Keyword = 14
    Snippet = 15
    Color = 16
    File = 17
    Reference = 18
    Folder = 19
    EnumMember = 20
    Constant = 21
    Struct = 22
    Event = 23
    Operator = 24
    TypeParameter = 25

# commented out, because there is already an enumeration with the same name
# CompletionItemKind = int


# source file: "language/publishDiagnostics.md"


class PublishDiagnosticsClientCapabilities(TypedDict):
    class TagSupport_0(TypedDict):

        # The tags supported by the client.
        valueSet: List[DiagnosticTag]

    # Whether the clients accepts diagnostics with related information.
    relatedInformation: NotRequired[bool]

    # Client supports the tag property to provide meta data about a diagnostic.
    # Clients supporting tags have to handle unknown tags gracefully.

    # @since 3.15.0
    tagSupport: NotRequired[TagSupport_0]

    # Whether the client interprets the version property of the
    # `textDocument/publishDiagnostics` notificationʼs parameter.

    # @since 3.15.0
    versionSupport: NotRequired[bool]

    # Client supports a codeDescription property

    # @since 3.16.0
    codeDescriptionSupport: NotRequired[bool]

    # Whether code action supports the `data` property which is
    # preserved between a `textDocument/publishDiagnostics` and
    # `textDocument/codeAction` request.

    # @since 3.16.0
    dataSupport: NotRequired[bool]


class PublishDiagnosticsParams(TypedDict):

    # The URI for which diagnostic information is reported.
    uri: DocumentUri

    # Optional the version number of the document the diagnostics are published
    # for.

    # @since 3.15.0
    version: NotRequired[int]

    # An array of diagnostic information items.
    diagnostics: List[Diagnostic]


# source file: "language/pullDiagnostics.md"

# Client capabilities specific to diagnostic pull requests.

# @since 3.17.0


class DiagnosticClientCapabilities(TypedDict):

    # Whether implementation supports dynamic registration. If this is set to
    # `true` the client supports the new
    # `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
    # return value for the corresponding server capability as well.
    dynamicRegistration: NotRequired[bool]

    # Whether the clients supports related documents for document diagnostic
    # pulls.
    relatedDocumentSupport: NotRequired[bool]

    # Whether the clients accepts diagnostics with related information.
    relatedInformation: NotRequired[bool]

    # Client supports the tag property to provide meta data about a diagnostic.
    # Clients supporting tags have to handle unknown tags gracefully.
    tagSupport: NotRequired['ClientDiagnosticsTagOptions']

    # Client supports a codeDescription property
    codeDescriptionSupport: NotRequired[bool]

    # Whether code action supports the `data` property which is
    # preserved between a `textDocument/publishDiagnostics` and
    # `textDocument/codeAction` request.
    dataSupport: NotRequired[bool]


# Diagnostic options.

# @since 3.17.0


class DiagnosticOptions(WorkDoneProgressOptions, TypedDict):

    # An optional identifier under which the diagnostics are
    # managed by the client.
    identifier: NotRequired[str]

    # Whether the language has inter file dependencies meaning that
    # editing code in one file can result in a different diagnostic
    # set in another file. Inter file dependencies are common for
    # most programming languages and typically uncommon for linters.
    interFileDependencies: bool

    # The server provides support for workspace diagnostics as well.
    workspaceDiagnostics: bool


# Diagnostic registration options.

# @since 3.17.0


class DiagnosticRegistrationOptions(TextDocumentRegistrationOptions, DiagnosticOptions, StaticRegistrationOptions, TypedDict):
    pass


class DocumentDiagnosticParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier

    # The additional identifier  provided during registration.
    identifier: NotRequired[str]

    # The result id of a previous response if provided.
    previousResultId: NotRequired[str]


# The result of a document diagnostic pull request. A report can
# either be a full report containing all diagnostics for the
# requested document or a unchanged report indicating that nothing
# has changed in terms of diagnostics in comparison to the last
# pull request.

# @since 3.17.0

DocumentDiagnosticReport = Union['RelatedFullDocumentDiagnosticReport', 'RelatedUnchangedDocumentDiagnosticReport']


# The document diagnostic report kinds.

# @since 3.17.0

class DocumentDiagnosticReportKind(Enum):

    # A diagnostic report with a full
    # set of problems.
    Full = "full"

    # A report indicating that the last
    # returned report is still accurate.
    Unchanged = "unchanged"

# commented out, because there is already an enumeration with the same name
# DocumentDiagnosticReportKind = str


# A diagnostic report with a full set of problems.

# @since 3.17.0


class FullDocumentDiagnosticReport(TypedDict):

    # A full document diagnostic report.
    kind: 'DocumentDiagnosticReportKind.Full'

    # An optional result id. If provided it will
    # be sent on the next diagnostic request for the
    # same document.
    resultId: NotRequired[str]

    # The actual items.
    items: List[Diagnostic]


# A diagnostic report indicating that the last returned
# report is still accurate.

# @since 3.17.0


class UnchangedDocumentDiagnosticReport(TypedDict):

    # A document diagnostic report indicating
    # no changes to the last result. A server can
    # only return `unchanged` if result ids are
    # provided.
    kind: 'DocumentDiagnosticReportKind.Unchanged'

    # A result id which will be sent on the next
    # diagnostic request for the same document.
    resultId: str


# A full diagnostic report with a set of related documents.

# @since 3.17.0


class RelatedFullDocumentDiagnosticReport(FullDocumentDiagnosticReport, TypedDict):

    # Diagnostics of related documents. This information is useful
    # in programming languages where code in a file A can generate
    # diagnostics in a file B which A depends on. An example of
    # such a language is C/C++ where macro definitions in a file
    # a.cpp and result in errors in a header file b.hpp.

    # @since 3.17.0
    relatedDocuments: NotRequired[Dict[str, Union[FullDocumentDiagnosticReport, UnchangedDocumentDiagnosticReport]]]


# An unchanged diagnostic report with a set of related documents.

# @since 3.17.0


class RelatedUnchangedDocumentDiagnosticReport(UnchangedDocumentDiagnosticReport, TypedDict):

    # Diagnostics of related documents. This information is useful
    # in programming languages where code in a file A can generate
    # diagnostics in a file B which A depends on. An example of
    # such a language is C/C++ where macro definitions in a file
    # a.cpp and result in errors in a header file b.hpp.

    # @since 3.17.0
    relatedDocuments: NotRequired[Dict[str, Union[FullDocumentDiagnosticReport, UnchangedDocumentDiagnosticReport]]]


# A partial result for a document diagnostic report.

# @since 3.17.0


class DocumentDiagnosticReportPartialResult(TypedDict):
    relatedDocuments: Dict[str, Union[FullDocumentDiagnosticReport, UnchangedDocumentDiagnosticReport]]


# Cancellation data returned from a diagnostic request.

# @since 3.17.0


class DiagnosticServerCancellationData(TypedDict):
    retriggerRequest: bool


# Parameters of the workspace diagnostic request.

# @since 3.17.0


class WorkspaceDiagnosticParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The additional identifier provided during registration.
    identifier: NotRequired[str]

    # The currently known diagnostic reports with their
    # previous result ids.
    previousResultIds: List['PreviousResultId']


# A previous result id in a workspace pull request.

# @since 3.17.0


class PreviousResultId(TypedDict):

    # The URI for which the client knows a
    # result id.
    uri: DocumentUri

    # The value of the previous result id.
    value: str


# A workspace diagnostic report.

# @since 3.17.0


class WorkspaceDiagnosticReport(TypedDict):
    items: List['WorkspaceDocumentDiagnosticReport']


# A full document diagnostic report for a workspace diagnostic result.

# @since 3.17.0


class WorkspaceFullDocumentDiagnosticReport(FullDocumentDiagnosticReport, TypedDict):

    # The URI for which diagnostic information is reported.
    uri: DocumentUri

    # The version number for which the diagnostics are reported.
    # If the document is not marked as open `null` can be provided.
    version: Union[int, None]


# An unchanged document diagnostic report for a workspace diagnostic result.

# @since 3.17.0


class WorkspaceUnchangedDocumentDiagnosticReport(UnchangedDocumentDiagnosticReport, TypedDict):

    # The URI for which diagnostic information is reported.
    uri: DocumentUri

    # The version number for which the diagnostics are reported.
    # If the document is not marked as open `null` can be provided.
    version: Union[int, None]


# A workspace diagnostic document report.

# @since 3.17.0

WorkspaceDocumentDiagnosticReport = Union[WorkspaceFullDocumentDiagnosticReport, WorkspaceUnchangedDocumentDiagnosticReport]


# A partial result for a workspace diagnostic report.

# @since 3.17.0


class WorkspaceDiagnosticReportPartialResult(TypedDict):
    items: List[WorkspaceDocumentDiagnosticReport]


# Workspace client capabilities specific to diagnostic pull requests.

# @since 3.17.0


class DiagnosticWorkspaceClientCapabilities(TypedDict):

    # Whether the client implementation supports a refresh request sent from
    # the server to the client.

    # Note that this event is global and will force the client to refresh all
    # pulled diagnostics currently shown. It should be used with absolute care
    # and is useful for situation where a server for example detects a project
    # wide change that requires such a calculation.
    refreshSupport: NotRequired[bool]


# source file: "language/signatureHelp.md"


class SignatureHelpClientCapabilities(TypedDict):
    class SignatureInformation_0(TypedDict):
        class ParameterInformation_0(TypedDict):

            # The client supports processing label offsets instead of a
            # simple label string.

            # @since 3.14.0
            labelOffsetSupport: NotRequired[bool]

        # Client supports the follow content formats for the documentation
        # property. The order describes the preferred format of the client.
        documentationFormat: NotRequired[List[MarkupKind]]

        # Client capabilities specific to parameter information.
        parameterInformation: NotRequired[ParameterInformation_0]

        # The client supports the `activeParameter` property on
        # `SignatureInformation` literal.

        # @since 3.16.0
        activeParameterSupport: NotRequired[bool]

    # Whether signature help supports dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # The client supports the following `SignatureInformation`
    # specific properties.
    signatureInformation: NotRequired[SignatureInformation_0]

    # The client supports to send additional context information for a
    # `textDocument/signatureHelp` request. A client that opts into
    # contextSupport will also support the `retriggerCharacters` on
    # `SignatureHelpOptions`.

    # @since 3.15.0
    contextSupport: NotRequired[bool]


class SignatureHelpOptions(WorkDoneProgressOptions, TypedDict):

    # The characters that trigger signature help
    # automatically.
    triggerCharacters: NotRequired[List[str]]

    # List of characters that re-trigger signature help.

    # These trigger characters are only active when signature help is already
    # showing. All trigger characters are also counted as re-trigger
    # characters.

    # @since 3.15.0
    retriggerCharacters: NotRequired[List[str]]


class SignatureHelpRegistrationOptions(TextDocumentRegistrationOptions, SignatureHelpOptions, TypedDict):
    pass


class SignatureHelpParams(TextDocumentPositionParams, WorkDoneProgressParams, TypedDict):

    # The signature help context. This is only available if the client
    # specifies to send this using the client capability
    # `textDocument.signatureHelp.contextSupport === true`

    # @since 3.15.0
    context: NotRequired['SignatureHelpContext']


# How a signature help was triggered.

# @since 3.15.0

class SignatureHelpTriggerKind(IntEnum):

    # Signature help was invoked manually by the user or by a command.
    Invoked = 1

    # Signature help was triggered by a trigger character.
    TriggerCharacter = 2

    # Signature help was triggered by the cursor moving or by the document
    # content changing.
    ContentChange = 3

# commented out, because there is already an enumeration with the same name
# SignatureHelpTriggerKind = int


# Additional information about the context in which a signature help request
# was triggered.

# @since 3.15.0


class SignatureHelpContext(TypedDict):

    # Action that caused signature help to be triggered.
    triggerKind: SignatureHelpTriggerKind

    # Character that caused signature help to be triggered.

    # This is undefined when triggerKind !==
    # SignatureHelpTriggerKind.TriggerCharacter
    triggerCharacter: NotRequired[str]

    # `true` if signature help was already showing when it was triggered.

    # Retriggers occur when the signature help is already active and can be
    # caused by actions such as typing a trigger character, a cursor move, or
    # document content changes.
    isRetrigger: bool

    # The currently active `SignatureHelp`.

    # The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field
    # updated based on the user navigating through available signatures.
    activeSignatureHelp: NotRequired['SignatureHelp']


# Signature help represents the signature of something
# callable. There can be multiple signature but only one
# active and only one active parameter.


class SignatureHelp(TypedDict):

    # One or more signatures. If no signatures are available the signature help
    # request should return `null`.
    signatures: List['SignatureInformation']

    # The active signature. If omitted or the value lies outside the
    # range of `signatures` the value defaults to zero or is ignore if
    # the `SignatureHelp` as no signatures.

    # Whenever possible implementors should make an active decision about
    # the active signature and shouldnʼt rely on a default value.

    # In future version of the protocol this property might become
    # mandatory to better express this.
    activeSignature: NotRequired[int]

    # The active parameter of the active signature. If omitted or the value
    # lies outside the range of `signatures[activeSignature].parameters`
    # defaults to 0 if the active signature has parameters. If
    # the active signature has no parameters it is ignored.
    # In future version of the protocol this property might become
    # mandatory to better express the active parameter if the
    # active signature does have any.
    activeParameter: NotRequired[int]


# Represents the signature of something callable. A signature
# can have a label, like a function-name, a doc-comment, and
# a set of parameters.


class SignatureInformation(TypedDict):

    # The label of this signature. Will be shown in
    # the UI.
    label: str

    # The human-readable doc-comment of this signature. Will be shown
    # in the UI but can be omitted.
    documentation: NotRequired[Union[str, MarkupContent]]

    # The parameters of this signature.
    parameters: NotRequired[List['ParameterInformation']]

    # The index of the active parameter.

    # If provided, this is used in place of `SignatureHelp.activeParameter`.

    # @since 3.16.0
    activeParameter: NotRequired[int]


# Represents a parameter of a callable-signature. A parameter can
# have a label and a doc-comment.


class ParameterInformation(TypedDict):

    # The label of this parameter information.

    # Either a string or an inclusive start and exclusive end offsets within
    # its containing signature label. (see SignatureInformation.label). The
    # offsets are based on a UTF-16 string representation as `Position` and
    # `Range` does.

    # *Note*: a label of type string should be a substring of its containing
    # signature label. Its intended use case is to highlight the parameter
    # label part in the `SignatureInformation.label`.
    label: Union[str, Tuple[int, int]]

    # The human-readable doc-comment of this parameter. Will be shown
    # in the UI but can be omitted.
    documentation: NotRequired[Union[str, MarkupContent]]


# source file: "language/codeAction.md"


class CodeActionClientCapabilities(TypedDict):
    class CodeActionLiteralSupport_0(TypedDict):
        class CodeActionKind_0(TypedDict):

            # The code action kind values the client supports. When this
            # property exists the client also guarantees that it will
            # handle values outside its set gracefully and falls back
            # to a default value when unknown.
            valueSet: List['CodeActionKind']

        # The code action kind is supported with the following value
        # set.
        codeActionKind: CodeActionKind_0
    class ResolveSupport_0(TypedDict):

        # The properties that a client can resolve lazily.
        properties: List[str]

    # Whether code action supports dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # The client supports code action literals as a valid
    # response of the `textDocument/codeAction` request.

    # @since 3.8.0
    codeActionLiteralSupport: NotRequired[CodeActionLiteralSupport_0]

    # Whether code action supports the `isPreferred` property.

    # @since 3.15.0
    isPreferredSupport: NotRequired[bool]

    # Whether code action supports the `disabled` property.

    # @since 3.16.0
    disabledSupport: NotRequired[bool]

    # Whether code action supports the `data` property which is
    # preserved between a `textDocument/codeAction` and a
    # `codeAction/resolve` request.

    # @since 3.16.0
    dataSupport: NotRequired[bool]

    # Whether the client supports resolving additional code action
    # properties via a separate `codeAction/resolve` request.

    # @since 3.16.0
    resolveSupport: NotRequired[ResolveSupport_0]

    # Whether the client honors the change annotations in
    # text edits and resource operations returned via the
    # `CodeAction#edit` property by for example presenting
    # the workspace edit in the user interface and asking
    # for confirmation.

    # @since 3.16.0
    honorsChangeAnnotations: NotRequired[bool]


class CodeActionOptions(WorkDoneProgressOptions, TypedDict):

    # CodeActionKinds that this server may return.

    # The list of kinds may be generic, such as `CodeActionKind.Refactor`,
    # or the server may list out every specific kind they provide.
    codeActionKinds: NotRequired[List['CodeActionKind']]

    # The server provides support to resolve additional
    # information for a code action.

    # @since 3.16.0
    resolveProvider: NotRequired[bool]


class CodeActionRegistrationOptions(TextDocumentRegistrationOptions, CodeActionOptions, TypedDict):
    pass


class CodeActionParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The document in which the command was invoked.
    textDocument: TextDocumentIdentifier

    # The range for which the command was invoked.
    range: Range

    # Context carrying additional information.
    context: 'CodeActionContext'


# The kind of a code action.

# Kinds are a hierarchical list of identifiers separated by `.`,
# e.g. `"refactor.extract.function"`.

# The set of kinds is open and client needs to announce the kinds it supports
# to the server during initialization.

CodeActionKind = str


# A set of predefined code action kinds.

class CodeActionKind(Enum):

    # Empty kind.
    Empty = ""

    # Base kind for quickfix actions: ʼquickfixʼ.
    QuickFix = "quickfix"

    # Base kind for refactoring actions: ʼrefactorʼ.
    Refactor = "refactor"

    # Base kind for refactoring extraction actions: ʼrefactor.extractʼ.

    # Example extract actions:

    # - Extract method
    # - Extract function
    # - Extract variable
    # - Extract interface from class
    # - ...
    RefactorExtract = "refactor.extract"

    # Base kind for refactoring inline actions: ʼrefactor.inlineʼ.

    # Example inline actions:

    # - Inline function
    # - Inline variable
    # - Inline constant
    # - ...
    RefactorInline = "refactor.inline"

    # Base kind for refactoring rewrite actions: ʼrefactor.rewriteʼ.

    # Example rewrite actions:

    # - Convert JavaScript function to class
    # - Add or remove parameter
    # - Encapsulate field
    # - Make method static
    # - Move method to base class
    # - ...
    RefactorRewrite = "refactor.rewrite"

    # Base kind for source actions: `source`.

    # Source code actions apply to the entire file.
    Source = "source"

    # Base kind for an organize imports source action:
    # `source.organizeImports`.
    SourceOrganizeImports = "source.organizeImports"

    # Base kind for a ʼfix allʼ source action: `source.fixAll`.

    # ʼFix allʼ actions automatically fix errors that have a clear fix that
    # do not require user input. They should not suppress errors or perform
    # unsafe fixes such as generating new types or classes.

    # @since 3.17.0
    SourceFixAll = "source.fixAll"


# Contains additional diagnostic information about the context in which
# a code action is run.


class CodeActionContext(TypedDict):

    # An array of diagnostics known on the client side overlapping the range
    # provided to the `textDocument/codeAction` request. They are provided so
    # that the server knows which errors are currently presented to the user
    # for the given range. There is no guarantee that these accurately reflect
    # the error state of the resource. The primary parameter
    # to compute code actions is the provided range.
    diagnostics: List[Diagnostic]

    # Requested kind of actions to return.

    # Actions not of this kind are filtered out by the client before being
    # shown. So servers can omit computing them.
    only: NotRequired[List[CodeActionKind]]

    # The reason why code actions were requested.

    # @since 3.17.0
    triggerKind: NotRequired['CodeActionTriggerKind']


# The reason why code actions were requested.

# @since 3.17.0

class CodeActionTriggerKind(IntEnum):

    # Code actions were explicitly requested by the user or by an extension.
    Invoked = 1

    # Code actions were requested automatically.

    # This typically happens when current selection in a file changes, but can
    # also be triggered when file content changes.
    Automatic = 2

# commented out, because there is already an enumeration with the same name
# CodeActionTriggerKind = int


# A code action represents a change that can be performed in code, e.g. to fix
# a problem or to refactor code.

# A CodeAction must set either `edit` and/or a `command`. If both are supplied,
# the `edit` is applied first, then the `command` is executed.


class CodeAction(TypedDict):
    class Disabled_0(TypedDict):

        # Human readable description of why the code action is currently
        # disabled.

        # This is displayed in the code actions UI.
        reason: str

    # A short, human-readable, title for this code action.
    title: str

    # The kind of the code action.

    # Used to filter code actions.
    kind: NotRequired[CodeActionKind]

    # The diagnostics that this code action resolves.
    diagnostics: NotRequired[List[Diagnostic]]

    # Marks this as a preferred action. Preferred actions are used by the
    # `auto fix` command and can be targeted by keybindings.

    # A quick fix should be marked preferred if it properly addresses the
    # underlying error. A refactoring should be marked preferred if it is the
    # most reasonable choice of actions to take.

    # @since 3.15.0
    isPreferred: NotRequired[bool]

    # Marks that the code action cannot currently be applied.

    # Clients should follow the following guidelines regarding disabled code
    # actions:

    # - Disabled code actions are not shown in automatic lightbulbs code
    # action menus.

    # - Disabled actions are shown as faded out in the code action menu when
    # the user request a more specific type of code action, such as
    # refactorings.

    # - If the user has a keybinding that auto applies a code action and only
    # a disabled code actions are returned, the client should show the user
    # an error message with `reason` in the editor.

    # @since 3.16.0
    disabled: NotRequired[Disabled_0]

    # The workspace edit this code action performs.
    edit: NotRequired[WorkspaceEdit]

    # A command this code action executes. If a code action
    # provides an edit and a command, first the edit is
    # executed and then the command.
    command: NotRequired[Command]

    # A data entry field that is preserved on a code action between
    # a `textDocument/codeAction` and a `codeAction/resolve` request.

    # @since 3.16.0
    data: NotRequired[LSPAny]


class DocumentColorClientCapabilities(TypedDict):

    # Whether document color supports dynamic registration.
    dynamicRegistration: NotRequired[bool]


class DocumentColorOptions(WorkDoneProgressOptions, TypedDict):
    pass


class DocumentColorRegistrationOptions(TextDocumentRegistrationOptions, StaticRegistrationOptions, DocumentColorOptions, TypedDict):
    pass


class DocumentColorParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier


class ColorInformation(TypedDict):

    # The range in the document where this color appears.
    range: Range

    # The actual color value for this color range.
    color: 'Color'


# Represents a color in RGBA space.


class Color(TypedDict):

    # The red component of this color in the range [0-1].
    red: ReadOnly[float]

    # The green component of this color in the range [0-1].
    green: ReadOnly[float]

    # The blue component of this color in the range [0-1].
    blue: ReadOnly[float]

    # The alpha component of this color in the range [0-1].
    alpha: ReadOnly[float]


# source file: "language/colorPresentation.md"


class ColorPresentationParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # The text document.
    textDocument: TextDocumentIdentifier

    # The color information to request presentations for.
    color: Color

    # The range where the color would be inserted. Serves as a context.
    range: Range


class ColorPresentation(TypedDict):

    # The label of this color presentation. It will be shown on the color
    # picker header. By default this is also the text that is inserted when
    # selecting this color presentation.
    label: str

    # An [edit](#TextEdit) which is applied to a document when selecting
    # this presentation for the color. When omitted the
    # [label](#ColorPresentation.label) is used.
    textEdit: NotRequired[TextEdit]

    # An optional array of additional [text edits](#TextEdit) that are applied
    # when selecting this color presentation. Edits must not overlap with the
    # main [edit](#ColorPresentation.textEdit) nor with themselves.
    additionalTextEdits: NotRequired[List[TextEdit]]


# source file: "language/formatting.md"


class DocumentFormattingClientCapabilities(TypedDict):

    # Whether formatting supports dynamic registration.
    dynamicRegistration: NotRequired[bool]


class DocumentFormattingOptions(WorkDoneProgressOptions, TypedDict):
    pass


class DocumentFormattingRegistrationOptions(TextDocumentRegistrationOptions, DocumentFormattingOptions, TypedDict):
    pass


class DocumentFormattingParams(WorkDoneProgressParams, TypedDict):

    # The document to format.
    textDocument: TextDocumentIdentifier

    # The format options.
    options: 'FormattingOptions'


# Value-object describing what options formatting should use.


class FormattingOptions(TypedDict):

    # Size of a tab in spaces.
    tabSize: int

    # Prefer spaces over tabs.
    insertSpaces: bool

    # Trim trailing whitespace on a line.

    # @since 3.15.0
    trimTrailingWhitespace: NotRequired[bool]

    # Insert a newline character at the end of the file if one does not exist.

    # @since 3.15.0
    insertFinalNewline: NotRequired[bool]

    # Trim all newlines after the final newline at the end of the file.

    # @since 3.15.0
    trimFinalNewlines: NotRequired[bool]

    # Signature for further properties.


# source file: "language/rangeFormatting.md"


class DocumentRangeFormattingClientCapabilities(TypedDict):

    # Whether formatting supports dynamic registration.
    dynamicRegistration: NotRequired[bool]


class DocumentRangeFormattingOptions(WorkDoneProgressOptions, TypedDict):
    pass


class DocumentRangeFormattingRegistrationOptions(TextDocumentRegistrationOptions, DocumentRangeFormattingOptions, TypedDict):
    pass


class DocumentRangeFormattingParams(WorkDoneProgressParams, TypedDict):

    # The document to format.
    textDocument: TextDocumentIdentifier

    # The range to format
    range: Range

    # The format options
    options: FormattingOptions


# source file: "language/onTypeFormatting.md"


class DocumentOnTypeFormattingClientCapabilities(TypedDict):

    # Whether on type formatting supports dynamic registration.
    dynamicRegistration: NotRequired[bool]


class DocumentOnTypeFormattingOptions(TypedDict):

    # A character on which formatting should be triggered, like `{`.
    firstTriggerCharacter: str

    # More trigger characters.
    moreTriggerCharacter: NotRequired[List[str]]


class DocumentOnTypeFormattingRegistrationOptions(TextDocumentRegistrationOptions, DocumentOnTypeFormattingOptions, TypedDict):
    pass


class DocumentOnTypeFormattingParams(TypedDict):

    # The document to format.
    textDocument: TextDocumentIdentifier

    # The position around which the on type formatting should happen.
    # This is not necessarily the exact position where the character denoted
    # by the property `ch` got typed.
    position: Position

    # The character that has been typed that triggered the formatting
    # on type request. That is not necessarily the last character that
    # got inserted into the document since the client could auto insert
    # characters as well (e.g. like automatic brace completion).
    ch: str

    # The formatting options.
    options: FormattingOptions


# source file: "language/rename.md"

class PrepareSupportDefaultBehavior(IntEnum):

    # The clientʼs default behavior is to select the identifier
    # according to the languageʼs syntax rule.
    Identifier = 1

# commented out, because there is already an enumeration with the same name
# PrepareSupportDefaultBehavior = int


class RenameClientCapabilities(TypedDict):

    # Whether rename supports dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # Client supports testing for validity of rename operations
    # before execution.

    # @since version 3.12.0
    prepareSupport: NotRequired[bool]

    # Client supports the default behavior result
    # (`{ defaultBehavior: boolean }`).

    # The value indicates the default behavior used by the
    # client.

    # @since version 3.16.0
    prepareSupportDefaultBehavior: NotRequired[PrepareSupportDefaultBehavior]

    # Whether the client honors the change annotations in
    # text edits and resource operations returned via the
    # rename requestʼs workspace edit by for example presenting
    # the workspace edit in the user interface and asking
    # for confirmation.

    # @since 3.16.0
    honorsChangeAnnotations: NotRequired[bool]


class RenameOptions(WorkDoneProgressOptions, TypedDict):

    # Renames should be checked and tested before being executed.
    prepareProvider: NotRequired[bool]


class RenameRegistrationOptions(TextDocumentRegistrationOptions, RenameOptions, TypedDict):
    pass


class RenameParams(TextDocumentPositionParams, WorkDoneProgressParams, TypedDict):

    # The new name of the symbol. If the given name is not valid the
    # request must return a [ResponseError](#ResponseError) with an
    # appropriate message set.
    newName: str


class PrepareRenameParams(TextDocumentPositionParams, WorkDoneProgressParams, TypedDict):
    pass


class LinkedEditingRangeClientCapabilities(TypedDict):

    # Whether the implementation supports dynamic registration.
    # If this is set to `true` the client supports the new
    # `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
    # return value for the corresponding server capability as well.
    dynamicRegistration: NotRequired[bool]


class LinkedEditingRangeOptions(WorkDoneProgressOptions, TypedDict):
    pass


class LinkedEditingRangeRegistrationOptions(TextDocumentRegistrationOptions, LinkedEditingRangeOptions, StaticRegistrationOptions, TypedDict):
    pass


class LinkedEditingRangeParams(TextDocumentPositionParams, WorkDoneProgressParams, TypedDict):
    pass


class LinkedEditingRanges(TypedDict):

    # A list of ranges that can be renamed together. The ranges must have
    # identical length and contain identical text content. The ranges cannot
    # overlap.
    ranges: List[Range]

    # An optional word pattern (regular expression) that describes valid
    # contents for the given ranges. If no pattern is provided, the client
    # configurationʼs word pattern will be used.
    wordPattern: NotRequired[str]


# source file: "workspace/symbol.md"


class WorkspaceSymbolClientCapabilities(TypedDict):
    class SymbolKind_0(TypedDict):

        # The symbol kind values the client supports. When this
        # property exists the client also guarantees that it will
        # handle values outside its set gracefully and falls back
        # to a default value when unknown.

        # If this property is not present the client only supports
        # the symbol kinds from `File` to `Array` as defined in
        # the initial version of the protocol.
        valueSet: NotRequired[List[SymbolKind]]
    class TagSupport_0(TypedDict):

        # The tags supported by the client.
        valueSet: List[SymbolTag]
    class ResolveSupport_0(TypedDict):

        # The properties that a client can resolve lazily. Usually
        # `location.range`
        properties: List[str]

    # Symbol request supports dynamic registration.
    dynamicRegistration: NotRequired[bool]

    # Specific capabilities for the `SymbolKind` in the `workspace/symbol`
    # request.
    symbolKind: NotRequired[SymbolKind_0]

    # The client supports tags on `SymbolInformation` and `WorkspaceSymbol`.
    # Clients supporting tags have to handle unknown tags gracefully.

    # @since 3.16.0
    tagSupport: NotRequired[TagSupport_0]

    # The client support partial workspace symbols. The client will send the
    # request `workspaceSymbol/resolve` to the server to resolve additional
    # properties.

    # @since 3.17.0 - proposedState
    resolveSupport: NotRequired[ResolveSupport_0]


class WorkspaceSymbolOptions(WorkDoneProgressOptions, TypedDict):

    # The server provides support to resolve additional
    # information for a workspace symbol.

    # @since 3.17.0
    resolveProvider: NotRequired[bool]


class WorkspaceSymbolRegistrationOptions(WorkspaceSymbolOptions, TypedDict):
    pass


class WorkspaceSymbolParams(WorkDoneProgressParams, PartialResultParams, TypedDict):

    # A query string to filter symbols by. Clients may send an empty
    # string here to request all symbols.
    query: str


# A special workspace symbol that supports locations without a range

# @since 3.17.0


class WorkspaceSymbol(TypedDict):
    class Location_1(TypedDict):
        uri: DocumentUri

    # The name of this symbol.
    name: str

    # The kind of this symbol.
    kind: SymbolKind

    # Tags for this completion item.
    tags: NotRequired[List[SymbolTag]]

    # The name of the symbol containing this symbol. This information is for
    # user interface purposes (e.g. to render a qualifier in the user interface
    # if necessary). It canʼt be used to re-infer a hierarchy for the document
    # symbols.
    containerName: NotRequired[str]

    # The location of this symbol. Whether a server is allowed to
    # return a location without a range depends on the client
    # capability `workspace.symbol.resolveSupport`.

    # See also `SymbolInformation.location`.
    location: Union[Location, Location_1]

    # A data entry field that is preserved on a workspace symbol between a
    # workspace symbol request and a workspace symbol resolve request.
    data: NotRequired[LSPAny]


# source file: "workspace/configuration.md"


class ConfigurationParams(TypedDict):
    items: List['ConfigurationItem']


class ConfigurationItem(TypedDict):

    # The scope to get the configuration section for.
    scopeUri: NotRequired[URI]

    # The configuration section asked for.
    section: NotRequired[str]


# source file: "workspace/didChangeConfiguration.md"


class DidChangeConfigurationClientCapabilities(TypedDict):

    # Did change configuration notification supports dynamic registration.

    # @since 3.6.0 to support the new pull model.
    dynamicRegistration: NotRequired[bool]


class DidChangeConfigurationParams(TypedDict):

    # The actual changed settings
    settings: LSPAny


# source file: "workspace/workspaceFolders.md"


class WorkspaceFoldersServerCapabilities(TypedDict):

    # The server has support for workspace folders
    supported: NotRequired[bool]

    # Whether the server wants to receive workspace folder
    # change notifications.

    # If a string is provided, the string is treated as an ID
    # under which the notification is registered on the client
    # side. The ID can be used to unregister for these events
    # using the `client/unregisterCapability` request.
    changeNotifications: NotRequired[Union[str, bool]]


class WorkspaceFolder(TypedDict):

    # The associated URI for this workspace folder.
    uri: URI

    # The name of the workspace folder. Used to refer to this
    # workspace folder in the user interface.
    name: str


# source file: "workspace/didChangeWorkspaceFolders.md"


class DidChangeWorkspaceFoldersParams(TypedDict):

    # The actual workspace folder change event.
    event: 'WorkspaceFoldersChangeEvent'


# The workspace folder change event.


class WorkspaceFoldersChangeEvent(TypedDict):

    # The array of added workspace folders
    added: List[WorkspaceFolder]

    # The array of the removed workspace folders
    removed: List[WorkspaceFolder]


# source file: "workspace/willCreateFiles.md"

# The options to register for file operations.

# @since 3.16.0


class FileOperationRegistrationOptions(TypedDict):

    # The actual filters.
    filters: List['FileOperationFilter']


# A pattern kind describing if a glob pattern matches a file a folder or
# both.

# @since 3.16.0

class FileOperationPatternKind(Enum):

    # The pattern matches a file only.
    file = "file"

    # The pattern matches a folder only.
    folder = "folder"

# commented out, because there is already an enumeration with the same name
# FileOperationPatternKind = str


# Matching options for the file operation pattern.

# @since 3.16.0


class FileOperationPatternOptions(TypedDict):

    # The pattern should be matched ignoring casing.
    ignoreCase: NotRequired[bool]


# A pattern to describe in which file operation requests or notifications
# the server is interested in.

# @since 3.16.0


class FileOperationPattern(TypedDict):

    # The glob pattern to match. Glob patterns can have the following syntax:
    # - `*` to match zero or more characters in a path segment
    # - `?` to match on one character in a path segment
    # - `**` to match any number of path segments, including none
    # - `{}` to group sub patterns into an OR expression. (e.g. `**​.{ts,js}`
    # matches all TypeScript and JavaScript files)
    # - `[]` to declare a range of characters to match in a path segment
    # (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
    # - `[!...]` to negate a range of characters to match in a path segment
    # (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but
    # not `example.0`)
    glob: str

    # Whether to match files or folders with this pattern.

    # Matches both if undefined.
    matches: NotRequired[FileOperationPatternKind]

    # Additional options used during matching.
    options: NotRequired[FileOperationPatternOptions]


# A filter to describe in which file operation requests or notifications
# the server is interested in.

# @since 3.16.0


class FileOperationFilter(TypedDict):

    # A Uri like `file` or `untitled`.
    scheme: NotRequired[str]

    # The actual file operation pattern.
    pattern: FileOperationPattern


# The parameters sent in notifications/requests for user-initiated creation
# of files.

# @since 3.16.0


class CreateFilesParams(TypedDict):

    # An array of all files/folders created in this operation.
    files: List['FileCreate']


# Represents information on a file/folder create.

# @since 3.16.0


class FileCreate(TypedDict):

    # A file:URI for the location of the file/folder being created.
    uri: str


# source file: "workspace/didCreateFiles.md"


# source file: "workspace/willRenameFiles.md"

# The parameters sent in notifications/requests for user-initiated renames
# of files.

# @since 3.16.0


class RenameFilesParams(TypedDict):

    # An array of all files/folders renamed in this operation. When a folder
    # is renamed, only the folder will be included, and not its children.
    files: List['FileRename']


# Represents information on a file/folder rename.

# @since 3.16.0


class FileRename(TypedDict):

    # A file:URI for the original location of the file/folder being renamed.
    oldUri: str

    # A file:URI for the new location of the file/folder being renamed.
    newUri: str


# source file: "workspace/didRenameFiles.md"


# source file: "workspace/willDeleteFiles.md"

# The parameters sent in notifications/requests for user-initiated deletes
# of files.

# @since 3.16.0


class DeleteFilesParams(TypedDict):

    # An array of all files/folders deleted in this operation.
    files: List['FileDelete']


# Represents information on a file/folder delete.

# @since 3.16.0


class FileDelete(TypedDict):

    # A file:URI for the location of the file/folder being deleted.
    uri: str


# source file: "workspace/didDeleteFiles.md"


# source file: "workspace/didChangeWatchedFiles.md"


class DidChangeWatchedFilesClientCapabilities(TypedDict):

    # Did change watched files notification supports dynamic registration.
    # Please note that the current protocol doesnʼt support static
    # configuration for file changes from the server side.
    dynamicRegistration: NotRequired[bool]

    # Whether the client has support for relative patterns
    # or not.

    # @since 3.17.0
    relativePatternSupport: NotRequired[bool]


# Describe options to be used when registering for file system change events.


class DidChangeWatchedFilesRegistrationOptions(TypedDict):

    # The watchers to register.
    watchers: List['FileSystemWatcher']


# The glob pattern to watch relative to the base path. Glob patterns can have
# the following syntax:
# - `*` to match zero or more characters in a path segment
# - `?` to match on one character in a path segment
# - `**` to match any number of path segments, including none
# - `{}` to group conditions (e.g. `**​.{ts,js}` matches all TypeScript
# and JavaScript files)
# - `[]` to declare a range of characters to match in a path segment
# (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)
# - `[!...]` to negate a range of characters to match in a path segment
# (e.g., `example.[!0-9]` to match on `example.a`, `example.b`,
# but not `example.0`)

# @since 3.17.0

Pattern = str


# A relative pattern is a helper to construct glob patterns that are matched
# relatively to a base URI. The common value for a `baseUri` is a workspace
# folder root, but it can be another absolute URI as well.

# @since 3.17.0


class RelativePattern(TypedDict):

    # A workspace folder or a base URI to which this pattern will be matched
    # against relatively.
    baseUri: Union[WorkspaceFolder, URI]

    # The actual glob pattern;
    pattern: Pattern


# The glob pattern. Either a string pattern or a relative pattern.

# @since 3.17.0

GlobPattern = Union[Pattern, RelativePattern]


class FileSystemWatcher(TypedDict):

    # The glob pattern to watch. See {@link GlobPattern glob pattern}
    # for more detail.

    # @since 3.17.0 support for relative patterns.
    globPattern: GlobPattern

    # The kind of events of interest. If omitted it defaults
    # to WatchKind.Create | WatchKind.Change | WatchKind.Delete
    # which is 7.
    kind: NotRequired['WatchKind']

class WatchKind(IntEnum):

    # Interested in create events.
    Create = 1

    # Interested in change events
    Change = 2

    # Interested in delete events
    Delete = 4

# commented out, because there is already an enumeration with the same name
# WatchKind = int


class DidChangeWatchedFilesParams(TypedDict):

    # The actual file events.
    changes: List['FileEvent']


# An event describing a file change.


class FileEvent(TypedDict):

    # The fileʼs URI.
    uri: DocumentUri

    # The change type.
    type: 'FileChangeType'


# The file event type.

class FileChangeType(IntEnum):

    # The file got created.
    Created = 1

    # The file got changed.
    Changed = 2

    # The file got deleted.
    Deleted = 3

# commented out, because there is already an enumeration with the same name
# FileChangeType = int


# source file: "workspace/executeCommand.md"


class ExecuteCommandClientCapabilities(TypedDict):

    # Execute command supports dynamic registration.
    dynamicRegistration: NotRequired[bool]


class ExecuteCommandOptions(WorkDoneProgressOptions, TypedDict):

    # The commands to be executed on the server
    commands: List[str]


# Execute command registration options.


class ExecuteCommandRegistrationOptions(ExecuteCommandOptions, TypedDict):
    pass


class ExecuteCommandParams(WorkDoneProgressParams, TypedDict):

    # The identifier of the actual command handler.
    command: str

    # Arguments that the command should be invoked with.
    arguments: NotRequired[List[LSPAny]]


# source file: "workspace/applyEdit.md"


class ApplyWorkspaceEditParams(TypedDict):

    # An optional label of the workspace edit. This label is
    # presented in the user interface for example on an undo
    # stack to undo the workspace edit.
    label: NotRequired[str]

    # The edits to apply.
    edit: WorkspaceEdit


class ApplyWorkspaceEditResult(TypedDict):

    # Indicates whether the edit was applied or not.
    applied: bool

    # An optional textual description for why the edit was not applied.
    # This may be used by the server for diagnostic logging or to provide
    # a suitable error for a request that triggered the edit.
    failureReason: NotRequired[str]

    # Depending on the clientʼs failure handling strategy `failedChange`
    # might contain the index of the change that failed. This property is
    # only available if the client signals a `failureHandling` strategy
    # in its client capabilities.
    failedChange: NotRequired[int]


# source file: "messages/3.17/showMessage.md"


class ShowMessageParams(TypedDict):

    # The message type. See {@link MessageType}.
    type: 'MessageType'

    # The actual message.
    message: str

class MessageType(IntEnum):

    # An error message.
    Error = 1

    # A warning message.
    Warning = 2

    # An information message.
    Info = 3

    # A log message.
    Log = 4

    # A debug message.

    # @since 3.18.0
    # @proposed
    Debug = 5

# commented out, because there is already an enumeration with the same name
# MessageType = int


# source file: "messages/3.17/showMessageRequest.md"

# Show message request client capabilities


class ShowMessageRequestClientCapabilities(TypedDict):
    class MessageActionItem_0(TypedDict):

        # Whether the client supports additional attributes which
        # are preserved and sent back to the server in the
        # requestʼs response.
        additionalPropertiesSupport: NotRequired[bool]

    # Capabilities specific to the `MessageActionItem` type.
    messageActionItem: NotRequired[MessageActionItem_0]


class ShowMessageRequestParams(TypedDict):

    # The message type. See {@link MessageType}
    type: MessageType

    # The actual message
    message: str

    # The message action items to present.
    actions: NotRequired[List['MessageActionItem']]


class MessageActionItem(TypedDict):

    # A short title like ʼRetryʼ, ʼOpen Logʼ etc.
    title: str


# source file: "window/showDocument.md"

# Client capabilities for the show document request.

# @since 3.16.0


class ShowDocumentClientCapabilities(TypedDict):

    # The client has support for the show document
    # request.
    support: bool


# Params to show a resource.

# @since 3.16.0


class ShowDocumentParams(TypedDict):

    # The uri to show.
    uri: URI

    # Indicates to show the resource in an external program.
    # To show, for example, `https:code.visualstudio.com/`
    # in the default WEB browser set `external` to `true`.
    external: NotRequired[bool]

    # An optional property to indicate whether the editor
    # showing the document should take focus or not.
    # Clients might ignore this property if an external
    # program is started.
    takeFocus: NotRequired[bool]

    # An optional selection range if the document is a text
    # document. Clients might ignore the property if an
    # external program is started or the file is not a text
    # file.
    selection: NotRequired[Range]


# The result of an show document request.

# @since 3.16.0


class ShowDocumentResult(TypedDict):

    # A boolean indicating if the show was successful.
    success: bool


# source file: "messages/3.17/logMessage.md"


class LogMessageParams(TypedDict):

    # The message type. See {@link MessageType}
    type: MessageType

    # The actual message
    message: str


# source file: "window/workDoneProgressCreate.md"


class WorkDoneProgressCreateParams(TypedDict):

    # The token to be used to report progress.
    token: ProgressToken


# source file: "window/workDoneProgressCancel.md"


class WorkDoneProgressCancelParams(TypedDict):

    # The token to be used to report progress.
    token: ProgressToken


# source file: "messages/3.17/telemetryEvent.md"



##### END OF ts2python generated code



#######################################################################
#
# Language-Server-Protocol functions
#
#######################################################################


# general #############################################################

# def get_lsp_methods(cls: Any, prefix: str= 'lsp_') -> List[str]:
#     """Returns the language-server-protocol-method-names from class ``cls``.
#     Methods are selected based on the prefix and their name converted in
#     accordance with the LSP-specification."""
#     return [gen_lsp_name(fn, prefix) for fn in lsp_candidates(cls, prefix)]


def lsp_candidates(cls: Any, prefix: str = 'lsp_') -> Iterator[str]:
    """Returns an iterator over all method names from a class that either
    have a certain prefix or, if no prefix was given, all non-special and
    non-private-methods of the class."""
    assert not prefix[:1] == '_'
    if prefix:
        # return [fn for fn in dir(cls) if fn.startswith(prefix) and callable(getattr(cls, fn))]
        for fn in dir(cls):
            if fn[:len(prefix)] == prefix and callable(getattr(cls, fn)):
                yield fn
    else:
        # return [fn for fn in dir(cls) if not fn.startswith('_') and callable(getattr(cls, fn))]
        for fn in dir(cls):
            if not fn[:1] == '_' and callable(getattr(cls, fn)):
                yield fn


def gen_lsp_name(func_name: str, prefix: str = 'lsp_') -> str:
    """Generates the name of an lsp-method from a function's name,
    e.g. "lsp_S_cancelRequest" -> "$/cancelRequest" """
    assert func_name[:len(prefix)] == prefix
    return func_name[len(prefix):].replace('_', '/').replace('S/', '$/')


def gen_lsp_table(lsp_funcs_or_instance: Union[Iterable[Callable], Any],
                  prefix: str = 'lsp_') -> Dict[str, Callable]:
    """Creates an RPC from a list of functions or from the methods
    of a class that implement the language server protocol.
    The dictionary keys are derived from the function name by replacing an
    underscore _ with a slash / and a single capital S with a $-sign.
    if ``prefix`` is not the empty string only functions or methods that start
    with ``prefix`` will be added to the table. The prefix will be removed
    before converting the functions' name to a dictionary key.

    >>> class LSP:
    ...     def lsp_initialize(self, **kw):
    ...         pass  # return InitializeResult
    ...     def lsp_shutdown(self, **kw):
    ...         pass
    >>> lsp = LSP()
    >>> gen_lsp_table(lsp, 'lsp_').keys()
    dict_keys(['initialize', 'shutdown'])
    """
    if isinstance(lsp_funcs_or_instance, Iterable):
        assert all(callable(func) for func in lsp_funcs_or_instance)
        rpc_table = {gen_lsp_name(func.__name__, prefix): func for func in lsp_funcs_or_instance}
    else:
        # assume lsp_funcs_or_instance is the instance of a class
        cls = lsp_funcs_or_instance
        rpc_table = {gen_lsp_name(fn, prefix): getattr(cls, fn)
                     for fn in lsp_candidates(cls, prefix)}
    return rpc_table


# textDocument/completion #############################################

def shortlist(long_list: List[str], typed: str, lo: int = 0, hi: int = -1) -> Tuple[int, int]:
    if not typed:
        return 0, 0
    if hi < 0:
        hi = len(long_list)
    import bisect
    a = bisect.bisect_left(long_list, typed, lo, hi)
    b = bisect.bisect_left(long_list, typed[:-1] + chr(ord(typed[-1]) + 1), lo, hi)
    return a, b


# LSPBase class #######################################################

class LSPTasks:
    def __init__(self, lsp_data: dict):
        self.lsp_data = lsp_data
        self.lsp_table = gen_lsp_table([], prefix='lsp_')

NO_TASKS = LSPTasks({})

class LSPBase:
    def __init__(self, cpu_bound: LSPTasks=NO_TASKS, blocking: LSPTasks=NO_TASKS):
        self.lsp_data = {
            'processId': 0,
            'rootUri': '',
            'clientCapabilities': {},
            'serverInfo': {"name": self.__class__.__name__, "version": "0.1"},
            'serverCapabilities': {
            }
        }
        self.connection = None
        self.cpu_bound = cpu_bound
        self.blocking = blocking
        self.lsp_table = gen_lsp_table(self, prefix='lsp_')
        self.lsp_fulltable = self.lsp_table.copy()
        assert self.lsp_fulltable.keys().isdisjoint(self.cpu_bound.lsp_table.keys())
        self.lsp_fulltable.update(self.cpu_bound.lsp_table)
        assert self.lsp_fulltable.keys().isdisjoint(self.blocking.lsp_table.keys())
        self.lsp_fulltable.update(self.blocking.lsp_table)

    def connect(self, connection):
        self.connection = connection

    def lsp_initialize(self, **kwargs) -> Dict:
        # InitializeParams -> InitializeResult
        self.lsp_data['processId'] = kwargs['processId']
        self.lsp_data['rootUri'] = kwargs['rootUri']
        self.lsp_data['clientCapabilities'] = kwargs['capabilities']
        return {'capabilities': self.lsp_data['serverCapabilities'],
                'serverInfo': self.lsp_data['serverInfo']}

    def lsp_initialized(self, params: InitializedParams) -> None:
        pass

    def lsp_shutdown(self) -> Dict:
        self.lsp_data['processId'] = 0
        self.lsp_data['rootUri'] = ''
        self.lsp_data['clientCapabilities'] = dict()
        return {}


if __name__ == "__main__":
    print("A small self-test of DHParser.lsp")
    print(DocumentSymbol.__required_keys__)
